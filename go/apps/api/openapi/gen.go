// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/oapi-codegen/nullable"
	"github.com/oapi-codegen/runtime"
)

const (
	RootKeyScopes = "rootKey.Scopes"
)

// Defines values for KeyCreditsRefillInterval.
const (
	KeyCreditsRefillIntervalDaily   KeyCreditsRefillInterval = "daily"
	KeyCreditsRefillIntervalMonthly KeyCreditsRefillInterval = "monthly"
)

// Defines values for KeysGetKeyResponseDataCreditsRefillInterval.
const (
	KeysGetKeyResponseDataCreditsRefillIntervalDaily   KeysGetKeyResponseDataCreditsRefillInterval = "daily"
	KeysGetKeyResponseDataCreditsRefillIntervalMonthly KeysGetKeyResponseDataCreditsRefillInterval = "monthly"
)

// Defines values for KeysUpdateRemainingResponseDataRefillSettingsInterval.
const (
	KeysUpdateRemainingResponseDataRefillSettingsIntervalDaily   KeysUpdateRemainingResponseDataRefillSettingsInterval = "daily"
	KeysUpdateRemainingResponseDataRefillSettingsIntervalMonthly KeysUpdateRemainingResponseDataRefillSettingsInterval = "monthly"
	KeysUpdateRemainingResponseDataRefillSettingsIntervalNever   KeysUpdateRemainingResponseDataRefillSettingsInterval = "never"
	KeysUpdateRemainingResponseDataRefillSettingsIntervalWeekly  KeysUpdateRemainingResponseDataRefillSettingsInterval = "weekly"
)

// Defines values for KeysVerifyKeyResponseDataCode.
const (
	DISABLED                KeysVerifyKeyResponseDataCode = "DISABLED"
	EXPIRED                 KeysVerifyKeyResponseDataCode = "EXPIRED"
	FORBIDDEN               KeysVerifyKeyResponseDataCode = "FORBIDDEN"
	INSUFFICIENTPERMISSIONS KeysVerifyKeyResponseDataCode = "INSUFFICIENT_PERMISSIONS"
	NOTFOUND                KeysVerifyKeyResponseDataCode = "NOT_FOUND"
	RATELIMITED             KeysVerifyKeyResponseDataCode = "RATE_LIMITED"
	UNAUTHORIZED            KeysVerifyKeyResponseDataCode = "UNAUTHORIZED"
	USAGEEXCEEDED           KeysVerifyKeyResponseDataCode = "USAGE_EXCEEDED"
	VALID                   KeysVerifyKeyResponseDataCode = "VALID"
)

// Defines values for V2KeysCreateKeyRequestBodyCreditsRefillInterval.
const (
	V2KeysCreateKeyRequestBodyCreditsRefillIntervalDaily   V2KeysCreateKeyRequestBodyCreditsRefillInterval = "daily"
	V2KeysCreateKeyRequestBodyCreditsRefillIntervalMonthly V2KeysCreateKeyRequestBodyCreditsRefillInterval = "monthly"
)

// Defines values for V2KeysUpdateKeyRequestBodyCreditsRefillInterval.
const (
	Daily   V2KeysUpdateKeyRequestBodyCreditsRefillInterval = "daily"
	Monthly V2KeysUpdateKeyRequestBodyCreditsRefillInterval = "monthly"
)

// Defines values for V2KeysVerifyKeyRequestBodyPermissions1Type.
const (
	And V2KeysVerifyKeyRequestBodyPermissions1Type = "and"
	Or  V2KeysVerifyKeyRequestBodyPermissions1Type = "or"
)

// ApisCreateApiResponseData defines model for ApisCreateApiResponseData.
type ApisCreateApiResponseData struct {
	// ApiId The id of the API
	ApiId string `json:"apiId"`
}

// ApisGetApiResponseData defines model for ApisGetApiResponseData.
type ApisGetApiResponseData struct {
	// Id The id of the API
	Id string `json:"id"`

	// Name The name of the API
	Name string `json:"name"`
}

// ApisListKeysResponseData defines model for ApisListKeysResponseData.
type ApisListKeysResponseData = []KeyResponse

// BadRequestErrorDetails defines model for BadRequestErrorDetails.
type BadRequestErrorDetails struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Errors Optional list of individual error details
	Errors []ValidationError `json:"errors"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code
	Status int `json:"status"`

	// Title A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
	Title string `json:"title"`

	// Type A URI reference to human-readable documentation for the error.
	Type string `json:"type"`
}

// BadRequestErrorResponse defines model for BadRequestErrorResponse.
type BadRequestErrorResponse struct {
	Error BadRequestErrorDetails `json:"error"`
	Meta  Meta                   `json:"meta"`
}

// BaseError defines model for BaseError.
type BaseError struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code
	Status int `json:"status"`

	// Title A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
	Title string `json:"title"`

	// Type A URI reference to human-readable documentation for the error.
	Type string `json:"type"`
}

// ConflictErrorResponse defines model for ConflictErrorResponse.
type ConflictErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// ForbiddenErrorResponse defines model for ForbiddenErrorResponse.
type ForbiddenErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// IdentitiesCreateIdentityResponseData defines model for IdentitiesCreateIdentityResponseData.
type IdentitiesCreateIdentityResponseData struct {
	// IdentityId The unique identifier for this identity in Unkey's system (begins with 'id_').
	//
	// This ID is generated automatically and used internally by Unkey to reference this identity. While you typically don't need to store this value (your externalId is sufficient), it can be useful to record it for:
	// - Debugging purposes
	// - Advanced API operations
	// - Integration with Unkey's analytics
	//
	// Unlike externalId which comes from your system, this ID is guaranteed unique across all Unkey workspaces.
	IdentityId string `json:"identityId"`
}

// Identity defines model for Identity.
type Identity struct {
	// ExternalId External identity ID
	ExternalId string `json:"externalId"`

	// Id Identity ID
	Id string `json:"id"`

	// Meta Identity metadata
	Meta *map[string]interface{} `json:"meta,omitempty"`
}

// InternalServerErrorResponse defines model for InternalServerErrorResponse.
type InternalServerErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// KeyCredits Remaining requests for this key
type KeyCredits struct {
	Refill *KeyCreditsRefill `json:"refill,omitempty"`

	// Remaining Remaining credits
	Remaining int `json:"remaining"`
}

// KeyCreditsRefill defines model for KeyCreditsRefill.
type KeyCreditsRefill struct {
	// Amount Amount to refill
	Amount int `json:"amount"`

	// Interval Refill interval
	Interval KeyCreditsRefillInterval `json:"interval"`

	// LastRefillAt Last time the key was refilled (Unix timestamp)
	LastRefillAt *int64 `json:"lastRefillAt,omitempty"`

	// RefillDay Day of the month when refill happens (for monthly interval)
	RefillDay *int `json:"refillDay,omitempty"`
}

// KeyCreditsRefillInterval Refill interval
type KeyCreditsRefillInterval string

// KeyResponse defines model for KeyResponse.
type KeyResponse struct {
	// CreatedAt When the key was created (Unix timestamp)
	CreatedAt int64 `json:"createdAt"`

	// Credits Remaining requests for this key
	Credits *KeyCredits `json:"credits,omitempty"`

	// Environment Optional environment tag
	Environment *string `json:"environment,omitempty"`

	// Expires When the key expires (Unix timestamp)
	Expires  *int64    `json:"expires,omitempty"`
	Identity *Identity `json:"identity,omitempty"`

	// KeyId The key ID
	KeyId string `json:"keyId"`

	// Meta Optional metadata for the key
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name Optional name for the key
	Name *string `json:"name,omitempty"`

	// Permissions Permissions assigned to this key
	Permissions *[]string `json:"permissions,omitempty"`

	// Plaintext The decrypted key value (only included if decrypt=true)
	Plaintext *string `json:"plaintext,omitempty"`

	// Roles Roles assigned to this key
	Roles *[]string `json:"roles,omitempty"`

	// Start The first few characters of the key
	Start string `json:"start"`

	// UpdatedAt When the key was last updated (Unix timestamp)
	UpdatedAt *int64 `json:"updatedAt,omitempty"`
}

// KeyWhoamiData defines model for KeyWhoamiData.
type KeyWhoamiData struct {
	// CreatedAt The timestamp in milliseconds when the key was created
	CreatedAt int64 `json:"createdAt"`

	// Enabled Whether the key is enabled and can be used
	Enabled bool `json:"enabled"`

	// Environment The environment the key is associated with (e.g., production, staging, development)
	Environment nullable.Nullable[string] `json:"environment,omitempty"`

	// Id The unique identifier of the key
	Id string `json:"id"`

	// Identity The identity object associated with the key (null if no identity is associated)
	Identity nullable.Nullable[struct {
		// ExternalId The external identity ID associated with the key (e.g., user ID in your system)
		ExternalId string `json:"externalId"`

		// Id The unique identity ID associated with the key
		Id string `json:"id"`
	}] `json:"identity,omitempty"`

	// Meta Custom metadata associated with the key (null if no metadata is present)
	Meta nullable.Nullable[map[string]interface{}] `json:"meta,omitempty"`

	// Name The human-readable name of the key (optional)
	Name nullable.Nullable[string] `json:"name,omitempty"`

	// Remaining The remaining number of requests for the key (null means unlimited)
	Remaining nullable.Nullable[int64] `json:"remaining,omitempty"`
}

// KeysCreateKeyResponseData defines model for KeysCreateKeyResponseData.
type KeysCreateKeyResponseData struct {
	// Key The full generated API key that should be securely provided to your user. SECURITY WARNING: This is the only time you'll receive the complete key - Unkey only stores a securely hashed version. Never log or store this value in your own systems; provide it directly to your end user via secure channels. After this API call completes, this value cannot be retrieved again (unless created with recoverable=true).
	Key string `json:"key"`

	// KeyId The unique identifier for this key in Unkey's system. This is NOT the actual API key, but a reference ID used for management operations like updating or deleting the key. Store this ID in your database to reference the key later. This ID is not sensitive and can be logged or displayed in dashboards.
	KeyId string `json:"keyId"`
}

// KeysDeleteKeyResponseData Empty response object. A successful response indicates the key was deleted successfully. Deletion triggers cache invalidation across all regions, but it may take up to 30 seconds for the deletion to be fully propagated due to eventual consistency. During this propagation period, some verification attempts might still succeed in certain regions.
type KeysDeleteKeyResponseData = map[string]interface{}

// KeysGetKeyResponseData defines model for KeysGetKeyResponseData.
type KeysGetKeyResponseData struct {
	// ApiId The ID of the API this key belongs to.
	ApiId *string `json:"apiId,omitempty"`

	// CreatedAt Unix timestamp (in milliseconds) when the key was created.
	CreatedAt int64 `json:"createdAt"`

	// Credits Usage limits configuration for this key. Credits provide a way to limit the number of times a key can be used before becoming invalid. Unlike ratelimits, credits are globally consistent (using database transactions) providing 100% accuracy at the cost of slightly higher latency. Ideal for monetization, usage quotas, or strict limits that must not be exceeded. See the 'refill' field for automatic replenishment options.
	Credits *struct {
		// Refill Configuration for automatic credit refills.
		Refill *struct {
			// Amount Number of credits added during each refill.
			Amount int `json:"amount"`

			// Interval How often the credits are automatically refilled.
			Interval KeysGetKeyResponseDataCreditsRefillInterval `json:"interval"`

			// LastRefillAt Unix timestamp (in milliseconds) when credits were last refilled.
			LastRefillAt *int64 `json:"lastRefillAt,omitempty"`

			// RefillDay For monthly refills, the day of month when refills occur.
			RefillDay *int `json:"refillDay,omitempty"`
		} `json:"refill,omitempty"`

		// Remaining The number of times this key can still be used before becoming invalid.
		Remaining *int32 `json:"remaining,omitempty"`
	} `json:"credits,omitempty"`

	// Enabled Whether the key is currently active. Disabled keys will fail verification with code=DISABLED. Toggling this allows you to temporarily suspend access without deleting the key, which is useful for maintenance, account freezing, or debugging. Can be updated using the updateKey endpoint.
	Enabled bool `json:"enabled"`

	// Expires Unix timestamp (in milliseconds) when this key will automatically expire. If null, the key has no expiration.
	Expires *int64 `json:"expires,omitempty"`

	// ExternalId Your user's unique identifier, creating a link between Unkey and your system. This ID is returned during verification so you can identify which customer/entity is making the request without performing additional database lookups. Use consistent identifiers that match your primary user/tenant identifiers for seamless integration.
	ExternalId *string `json:"externalId,omitempty"`

	// Id The unique identifier of the key in Unkey's system.
	Id string `json:"id"`

	// Identity The identity associated with this key, if any. Identities allow resource sharing (like ratelimits) across multiple keys belonging to the same user/entity. This enables scenarios like issuing separate keys for different devices/services while maintaining global usage limits for the user. An identity's externalId typically matches your user ID or tenant ID.
	Identity *struct {
		// ExternalId Your identifier for this identity in your system.
		ExternalId string `json:"externalId"`

		// Id The unique ID of the identity in Unkey's system.
		Id string `json:"id"`

		// Meta Additional metadata associated with this identity.
		Meta *map[string]interface{} `json:"meta,omitempty"`
	} `json:"identity,omitempty"`

	// Meta Arbitrary JSON metadata associated with this key. This can include additional context like subscription plans, feature flags, or any custom data. Metadata is stored as-is and returned during verification, allowing you to access important information without additional database queries. Consider including data relevant to authorization decisions, usage tracking, and user context.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name A descriptive name for the key for internal reference. Shown in dashboards and logs but never exposed to end users.
	Name *string `json:"name,omitempty"`

	// Permissions List of permission names directly assigned to this key.
	Permissions *[]string `json:"permissions,omitempty"`

	// Plaintext The full API key in plaintext. Only included when 'decrypt' is true and the key was created with 'recoverable: true'. SECURITY RISK: This field contains the actual secret key which should never be logged, stored in databases, or exposed in any frontend code. It should only be displayed directly to users through secure channels. Most applications should avoid setting decrypt=true unless absolutely necessary.
	Plaintext *string `json:"plaintext,omitempty"`

	// Ratelimits Array of ratelimits applied to this key. Multiple named ratelimits can control different aspects of key usage. For example, a 'requests' ratelimit might control overall API calls while a separate 'computations' limit manages access to resource-intensive operations. Ratelimits are optimized for performance and typically add minimal latency to verifications. They can be shared across keys through identities.
	Ratelimits *[]struct {
		// Async Whether this ratelimit uses fast (async=true) or consistent (async=false) mode. Fast mode has lower latency but less accuracy.
		Async *bool `json:"async,omitempty"`

		// Duration Duration of the ratelimit window in milliseconds.
		Duration int32 `json:"duration"`

		// Limit Maximum number of operations allowed within the time window.
		Limit int32 `json:"limit"`

		// Name Identifier for this ratelimit.
		Name string `json:"name"`
	} `json:"ratelimits,omitempty"`

	// Roles List of role names assigned to this key. Roles are collections of permissions.
	Roles *[]string `json:"roles,omitempty"`

	// Start The first few characters of the key to visually identify it without exposing the full key. Used in dashboards and logs to help users recognize which key is being used without revealing sensitive information. Typically includes the prefix if one was specified.
	Start string `json:"start"`

	// UpdatedAt Unix timestamp (in milliseconds) when the key was last updated.
	UpdatedAt *int64 `json:"updatedAt,omitempty"`

	// WorkspaceId The ID of the workspace that owns this key.
	WorkspaceId string `json:"workspaceId"`
}

// KeysGetKeyResponseDataCreditsRefillInterval How often the credits are automatically refilled.
type KeysGetKeyResponseDataCreditsRefillInterval string

// KeysUpdateKeyResponseData Empty response object by design. A successful response indicates the key was updated successfully. The endpoint doesn't return the updated key to reduce response size and avoid exposing sensitive information. Changes may take up to 30 seconds to propagate to all regions due to cache invalidation delays. If you need the updated key state, use a subsequent call to keys.getKey.
type KeysUpdateKeyResponseData = map[string]interface{}

// KeysUpdateRemainingResponseData defines model for KeysUpdateRemainingResponseData.
type KeysUpdateRemainingResponseData struct {
	// RefillSettings If the key has automatic refill settings, they are included here with their current configuration. If null, the key does not have automatic refills configured (either because they were removed with overwriteRefillSettings=true or because they were never set up). Refill settings create subscription-like behavior where the key automatically receives new credits on a regular schedule.
	RefillSettings nullable.Nullable[struct {
		// Amount The number of credits added during each automatic refill. This is the quota that gets renewed each period, making it useful for implementing subscription tiers with different usage limits (e.g., Basic=100/month, Pro=1000/month).
		Amount *int64 `json:"amount,omitempty"`

		// Interval The interval at which credits are automatically refilled. 'daily' resets at midnight UTC, 'weekly' resets on the specified weekday (where 1=Monday, 7=Sunday), 'monthly' resets on the specified day of month, and 'never' means no automatic refills occur.
		Interval *KeysUpdateRemainingResponseDataRefillSettingsInterval `json:"interval,omitempty"`

		// LastRefillAt The timestamp when the last automatic refill occurred. This helps track when credits were last replenished and understand when the next refill will occur. The timestamp is in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ).
		LastRefillAt *time.Time `json:"lastRefillAt,omitempty"`

		// RefillDay For monthly refills, the day of the month on which to refill (1-31). For weekly refills, the day of the week (1=Monday, 7=Sunday). This allows aligning refills with billing cycles, subscription periods, or other business-relevant schedules.
		RefillDay *int `json:"refillDay,omitempty"`
	}] `json:"refillSettings,omitempty"`

	// Remaining The updated remaining credits value for the key after the operation completes. This reflects the exact value that was set in the request. A value of -1 indicates unlimited usage, meaning the key can be used an unlimited number of times without being rejected for credit exhaustion. This field is guaranteed to be present in every response.
	Remaining int64 `json:"remaining"`
}

// KeysUpdateRemainingResponseDataRefillSettingsInterval The interval at which credits are automatically refilled. 'daily' resets at midnight UTC, 'weekly' resets on the specified weekday (where 1=Monday, 7=Sunday), 'monthly' resets on the specified day of month, and 'never' means no automatic refills occur.
type KeysUpdateRemainingResponseDataRefillSettingsInterval string

// KeysVerifyKeyResponseData defines model for KeysVerifyKeyResponseData.
type KeysVerifyKeyResponseData struct {
	// Code A machine-readable code indicating the verification status or failure reason. Values: VALID (key is valid), NOT_FOUND (key doesn't exist), FORBIDDEN (key exists but belongs to a different API), USAGE_EXCEEDED (key has no more credits), RATE_LIMITED (key exceeded rate limits), UNAUTHORIZED (key can't be used for this action), DISABLED (key was explicitly disabled), INSUFFICIENT_PERMISSIONS (key lacks required permissions), EXPIRED (key has passed its expiration date).
	Code KeysVerifyKeyResponseDataCode `json:"code"`

	// Credits The number of requests/credits remaining for this key. If null or not present, the key has unlimited usage. This value decreases with each verification (based on the 'cost' parameter) unless explicit credit refills are configured.
	Credits *int32 `json:"credits,omitempty"`

	// Enabled Indicates if the key is currently enabled. Disabled keys will always fail verification with code=DISABLED. This is useful for implementing temporary suspensions without deleting the key.
	Enabled *bool `json:"enabled,omitempty"`

	// Environment The environment tag associated with the key (e.g., 'production', 'staging', 'development'). Use this to further segment keys within an API beyond just the apiId separation.
	Environment *string `json:"environment,omitempty"`

	// Expires Unix timestamp (in milliseconds) when the key will expire. If null or not present, the key has no expiration. You can use this to warn users about upcoming expirations or to understand the validity period.
	Expires *int64 `json:"expires,omitempty"`

	// ExternalId Your user/tenant identifier that was associated with this key during creation. This allows you to connect the key back to your user without additional database lookups, making it ideal for implementing user-based authorization in stateless services.
	ExternalId *string   `json:"externalId,omitempty"`
	Identity   *Identity `json:"identity,omitempty"`

	// KeyId The unique identifier of the verified key in Unkey's system. Use this ID for operations like updating or revoking the key. This field is returned for both valid and invalid keys (except when code=NOT_FOUND).
	KeyId *string `json:"keyId,omitempty"`

	// Meta Custom metadata associated with the key. This can include any JSON-serializable data you stored with the key during creation or updates, such as plan information, feature flags, or user details. Use this to avoid additional database lookups for contextual information needed during API calls.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name The human-readable name assigned to this key during creation. This is useful for displaying in logs or admin interfaces to identify the key's purpose or owner.
	Name *string `json:"name,omitempty"`

	// Permissions A list of all permission names assigned to this key, either directly or through roles. These permissions determine what actions the key can perform. Only returned when permissions were checked during verification or when the key fails with code=INSUFFICIENT_PERMISSIONS.
	Permissions *[]string `json:"permissions,omitempty"`

	// Ratelimits Information about the rate limits applied during verification. Only included when rate limits were checked. If verification failed with code=RATE_LIMITED, this will show which specific rate limit was exceeded.
	Ratelimits *[]struct {
		// Limit The maximum number of operations allowed within the current time window for this rate limit.
		Limit int32 `json:"limit"`

		// Name The name of the rate limit that was checked. This matches the name provided in the request.
		Name string `json:"name"`

		// Remaining The number of operations still allowed within the current time window after this verification. Your application can use this to inform users about remaining capacity or to implement your own backoff strategies.
		Remaining int32 `json:"remaining"`

		// Reset Unix timestamp in milliseconds when the rate limit window will reset and 'remaining' will return to 'limit'. Use this to implement retry-after logic or to display wait times to users.
		Reset int64 `json:"reset"`
	} `json:"ratelimits,omitempty"`

	// Roles A list of all role names assigned to this key. Roles are collections of permissions that grant access to specific functionality. Only returned when permissions were checked during verification.
	Roles *[]string `json:"roles,omitempty"`

	// Valid The primary verification result. If true, the key is valid and can be used. If false, check the 'code' field to understand why verification failed. Your application should always check this field first before proceeding.
	Valid bool `json:"valid"`
}

// KeysVerifyKeyResponseDataCode A machine-readable code indicating the verification status or failure reason. Values: VALID (key is valid), NOT_FOUND (key doesn't exist), FORBIDDEN (key exists but belongs to a different API), USAGE_EXCEEDED (key has no more credits), RATE_LIMITED (key exceeded rate limits), UNAUTHORIZED (key can't be used for this action), DISABLED (key was explicitly disabled), INSUFFICIENT_PERMISSIONS (key lacks required permissions), EXPIRED (key has passed its expiration date).
type KeysVerifyKeyResponseDataCode string

// LivenessResponseData defines model for LivenessResponseData.
type LivenessResponseData struct {
	// Message Whether we're alive or not
	Message string `json:"message"`
}

// Meta defines model for Meta.
type Meta struct {
	// RequestId A unique id for this request. Please always provide this to support.
	RequestId string `json:"requestId"`
}

// NotFoundErrorResponse defines model for NotFoundErrorResponse.
type NotFoundErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	// Cursor Opaque token for retrieving the next set of results
	Cursor *string `json:"cursor,omitempty"`

	// HasMore Indicates if more results exist beyond this page
	HasMore *bool `json:"hasMore,omitempty"`
}

// Permission defines model for Permission.
type Permission struct {
	// CreatedAt When the permission was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description A description of what this permission grants access to
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the permission
	Id string `json:"id"`

	// Name The unique name of the permission
	Name string `json:"name"`

	// WorkspaceId The workspace this permission belongs to
	WorkspaceId string `json:"workspaceId"`
}

// PermissionsCreatePermissionResponseData defines model for PermissionsCreatePermissionResponseData.
type PermissionsCreatePermissionResponseData struct {
	// PermissionId The id of the permission. This is used internally
	PermissionId string `json:"permissionId"`
}

// PermissionsGetPermissionResponseData defines model for PermissionsGetPermissionResponseData.
type PermissionsGetPermissionResponseData struct {
	Permission Permission `json:"permission"`
}

// PermissionsListPermissionsResponseData defines model for PermissionsListPermissionsResponseData.
type PermissionsListPermissionsResponseData struct {
	// Cursor Cursor for pagination
	Cursor      *string      `json:"cursor,omitempty"`
	Permissions []Permission `json:"permissions"`

	// Total Total number of permissions
	Total int `json:"total"`
}

// PermissionsListRolesResponseData defines model for PermissionsListRolesResponseData.
type PermissionsListRolesResponseData struct {
	// Cursor Cursor for pagination
	Cursor *string               `json:"cursor,omitempty"`
	Roles  []RoleWithPermissions `json:"roles"`

	// Total Total number of roles
	Total int `json:"total"`
}

// PreconditionFailedErrorResponse defines model for PreconditionFailedErrorResponse.
type PreconditionFailedErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// Ratelimit defines model for Ratelimit.
type Ratelimit struct {
	// Duration The duration for each ratelimit window in milliseconds.
	//
	// This controls how long the rate limit counter accumulates before resetting. Common values include:
	// - 1000 (1 second): For strict per-second limits on high-frequency operations
	// - 60000 (1 minute): For moderate API usage control
	// - 3600000 (1 hour): For less frequent but costly operations
	// - 86400000 (24 hours): For daily quotas
	//
	// Shorter windows provide more frequent resets but may allow large burst usage. Longer windows provide more consistent usage patterns but take longer to reset after limit exhaustion.
	Duration int64 `json:"duration"`

	// Limit The maximum number of operations allowed within the specified time window.
	//
	// When this limit is reached, verification requests will fail with code=RATE_LIMITED until the window resets. The limit should reflect:
	// - Your infrastructure capacity and scaling limitations
	// - Fair usage expectations for your service
	// - Different tier levels for various user types
	// - The relative cost of the operations being limited
	//
	// Higher values allow more frequent access but may impact service performance.
	Limit int64 `json:"limit"`

	// Name The name of this rate limit. This name is used to identify which limit to check during key verification.
	//
	// Best practices for limit names:
	// - Use descriptive, semantic names like 'api_requests', 'heavy_operations', or 'downloads'
	// - Be consistent with naming conventions across your application
	// - Create separate limits for different resource types or operation costs
	// - Consider using namespaced names for better organization (e.g., 'files.downloads', 'compute.training')
	//
	// You will reference this exact name when verifying keys to check against this specific limit.
	Name string `json:"name"`
}

// RatelimitDeleteOverrideResponseData defines model for RatelimitDeleteOverrideResponseData.
type RatelimitDeleteOverrideResponseData = map[string]interface{}

// RatelimitLimitResponseData defines model for RatelimitLimitResponseData.
type RatelimitLimitResponseData struct {
	// Limit The maximum number of requests allowed.
	Limit int64 `json:"limit"`

	// OverrideId The override that was used. May be empty
	OverrideId *string `json:"overrideId,omitempty"`

	// Remaining The number of requests remaining in the current window.
	Remaining int64 `json:"remaining"`

	// Reset The time in milliseconds when the rate limit will reset.
	Reset int64 `json:"reset"`

	// Success Whether the request passed the ratelimit. If false, the request must be blocked.
	Success bool `json:"success"`
}

// RatelimitListOverridesResponseData defines model for RatelimitListOverridesResponseData.
type RatelimitListOverridesResponseData = []RatelimitOverride

// RatelimitOverride defines model for RatelimitOverride.
type RatelimitOverride struct {
	// Duration The duration in milliseconds for the rate limit window.
	Duration int64 `json:"duration"`

	// Identifier Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( * ) can be used to match multiple identifiers, More info can be found at https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules
	Identifier string `json:"identifier"`

	// Limit The maximum number of requests allowed.
	Limit int64 `json:"limit"`

	// NamespaceId The id of the namespace.
	NamespaceId string `json:"namespaceId"`

	// OverrideId The id of the override.
	OverrideId string `json:"overrideId"`
}

// RatelimitSetOverrideResponseData defines model for RatelimitSetOverrideResponseData.
type RatelimitSetOverrideResponseData struct {
	// OverrideId The id of the override. This is used internally.
	OverrideId string `json:"overrideId"`
}

// RoleWithPermissions defines model for RoleWithPermissions.
type RoleWithPermissions struct {
	// CreatedAt When the role was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description A description of what this role represents
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the role
	Id string `json:"id"`

	// Name The unique name of the role
	Name string `json:"name"`

	// Permissions The permissions assigned to this role
	Permissions []Permission `json:"permissions"`

	// WorkspaceId The workspace this role belongs to
	WorkspaceId string `json:"workspaceId"`
}

// UnauthorizedErrorResponse defines model for UnauthorizedErrorResponse.
type UnauthorizedErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// V2ApisCreateApiRequestBody defines model for V2ApisCreateApiRequestBody.
type V2ApisCreateApiRequestBody struct {
	// Name The name for your API. This is not customer facing.
	Name string `json:"name"`
}

// V2ApisCreateApiResponseBody defines model for V2ApisCreateApiResponseBody.
type V2ApisCreateApiResponseBody struct {
	Data ApisCreateApiResponseData `json:"data"`
	Meta Meta                      `json:"meta"`
}

// V2ApisDeleteApiRequestBody defines model for V2ApisDeleteApiRequestBody.
type V2ApisDeleteApiRequestBody struct {
	// ApiId The id of the API you want to delete. API ids always start with `api_`
	ApiId string `json:"apiId"`
}

// V2ApisDeleteApiResponseBody defines model for V2ApisDeleteApiResponseBody.
type V2ApisDeleteApiResponseBody struct {
	Meta Meta `json:"meta"`
}

// V2ApisGetApiRequestBody defines model for V2ApisGetApiRequestBody.
type V2ApisGetApiRequestBody struct {
	// ApiId The id of the api to fetch
	ApiId string `json:"apiId"`
}

// V2ApisGetApiResponseBody defines model for V2ApisGetApiResponseBody.
type V2ApisGetApiResponseBody struct {
	Data ApisGetApiResponseData `json:"data"`
	Meta Meta                   `json:"meta"`
}

// V2ApisListKeysRequestBody defines model for V2ApisListKeysRequestBody.
type V2ApisListKeysRequestBody struct {
	// ApiId The id of the api to fetch
	ApiId string `json:"apiId"`

	// Cursor Use this to fetch the next page of results. A new cursor will be returned in the response if there are more results.
	Cursor *string `json:"cursor,omitempty"`

	// Decrypt Decrypt and display the raw key. Only possible if the key was encrypted when generated.
	Decrypt *bool `json:"decrypt,omitempty"`

	// ExternalId If provided, this will only return keys where the `externalId` matches.
	ExternalId *string `json:"externalId,omitempty"`

	// Limit The maximum number of keys to return
	Limit *int `json:"limit,omitempty"`

	// RevalidateKeysCache EXPERIMENTAL: Skip the cache and fetch the keys from the database directly. When you're creating a key and immediately listing all keys to display them to your user, you might want to skip the cache to ensure the key is displayed immediately.
	RevalidateKeysCache *bool `json:"revalidateKeysCache,omitempty"`
}

// V2ApisListKeysResponseBody defines model for V2ApisListKeysResponseBody.
type V2ApisListKeysResponseBody struct {
	Data       ApisListKeysResponseData `json:"data"`
	Meta       Meta                     `json:"meta"`
	Pagination *Pagination              `json:"pagination,omitempty"`
}

// V2IdentitiesCreateIdentityRequestBody defines model for V2IdentitiesCreateIdentityRequestBody.
type V2IdentitiesCreateIdentityRequestBody struct {
	// ExternalId The id of this identity in your system.
	//
	// This should be a stable, unique identifier that represents a user, organization, or entity in your application. Common sources include:
	// - User IDs from your authentication system
	// - Organization/tenant IDs
	// - Customer IDs from your database
	// - Email addresses (if they serve as stable identifiers)
	//
	// Best practices:
	// - Use consistent identifier types across your application
	// - Prefer UUIDs or opaque IDs over sequential numbers
	// - Ensure the ID remains stable even if other user properties change
	// - Consider namespace prefixing (e.g., 'user_123', 'org_456') for clarity
	//
	// `externalId`s are unique across your workspace and therefore a `CONFLICT` error is returned when you try to create duplicates.
	ExternalId string `json:"externalId"`

	// Meta Attach metadata to this identity that you need to have access to when verifying a key.
	//
	// Metadata lets you store context with the identity that will be accessible during key verification without additional database lookups. This improves performance and reduces dependencies.
	//
	// Common metadata uses:
	// - User profile information (name, email, etc.)
	// - Subscription or plan details
	// - Feature flags and entitlements
	// - Usage limits or quotas
	// - Organization information
	// - Region or localization preferences
	//
	// This data is returned as-is in the `verifyKey` response when verifying any key associated with this identity.
	//
	// Note: Metadata should be kept reasonably small as it affects verification performance. For large data sets, consider storing only identifiers or essential information.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Ratelimits Attach ratelimits to this identity.
	//
	// Identity-based rate limits provide shared rate limiting across all keys belonging to the same identity. This is essential for:
	//
	// - Implementing fair usage policies across multiple API keys
	// - Preventing abuse by users with multiple keys
	// - Enforcing consistent limits regardless of how many keys a user creates
	// - Creating tiered access levels with different rate limits
	//
	// How it works:
	// - Rate limits defined here apply to all keys that share this identity
	// - During verification, specify which named limits to check
	// - Counters are shared across all keys with this identity
	// - Each named limit can have different thresholds and windows
	//
	// When verifying keys, you can specify which limits you want to use and all keys attached to this identity will share the limits, regardless of which specific key is used.
	Ratelimits *[]Ratelimit `json:"ratelimits,omitempty"`
}

// V2IdentitiesCreateIdentityResponseBody defines model for V2IdentitiesCreateIdentityResponseBody.
type V2IdentitiesCreateIdentityResponseBody struct {
	Data IdentitiesCreateIdentityResponseData `json:"data"`
	Meta Meta                                 `json:"meta"`
}

// V2IdentitiesDeleteIdentityRequestBody defines model for V2IdentitiesDeleteIdentityRequestBody.
type V2IdentitiesDeleteIdentityRequestBody struct {
	// ExternalId The id of this identity in your system.
	//
	// This should match the externalId value you used when creating the identity. You can use this field when you know the specific externalId but don't have the Unkey identityId. Only one of externalId or identityId is required.
	//
	// This identifier typically comes from your authentication system and could be a userId, organizationId, or any other stable unique identifier in your application.
	ExternalId *string `json:"externalId,omitempty"`

	// IdentityId The Unkey Identity ID (begins with 'id_').
	//
	// This is the internal unique identifier generated by Unkey when the identity was created. Use this when you have the specific Unkey ID and want to ensure you're targeting the exact identity. This is especially useful in automation scripts or when you need to guarantee you're operating on a specific identity regardless of externalId changes.
	//
	// Only one of externalId or identityId is required.
	IdentityId *string `json:"identityId,omitempty"`
	union      json.RawMessage
}

// V2IdentitiesDeleteIdentityRequestBody0 Identify by external ID from your system
type V2IdentitiesDeleteIdentityRequestBody0 = interface{}

// V2IdentitiesDeleteIdentityRequestBody1 Identify by Unkey's internal identity ID
type V2IdentitiesDeleteIdentityRequestBody1 = interface{}

// V2IdentitiesDeleteIdentityResponseBody Empty response object. A successful response indicates the identity was deleted successfully. The operation is immediate and permanent - the identity and all its associated data are removed from the system. Any API keys previously associated with this identity remain valid but are no longer linked to this identity.
type V2IdentitiesDeleteIdentityResponseBody struct {
	Meta Meta `json:"meta"`
}

// V2KeysAddPermissionsRequestBody defines model for V2KeysAddPermissionsRequestBody.
type V2KeysAddPermissionsRequestBody struct {
	// KeyId The ID of the key to which permissions will be added (begins with 'key_')
	KeyId string `json:"keyId"`

	// Permissions List of permissions to add to the key. Each permission can be identified by ID or name (if both are provided in the same object, ID takes precedence).
	//
	// Best practices:
	// - Use consistent naming patterns (e.g., 'resource.action' or 'resource.subresouce.action')
	// - Group related permissions (e.g., 'documents.read', 'documents.write', 'documents.delete')
	// - Use hierarchical naming for verification flexibility
	// - Consider creating a permission naming guide for your team
	//
	// Duplicate permissions are automatically handled (adding the same permission twice has no effect). During verification, hierarchical patterns are matched - a key with 'billing.*' permission will have access to 'billing.invoices.view'.
	Permissions []struct {
		// Create When true, if a permission with this name doesn't exist, it will be automatically created on-the-fly. Only works when specifying name, not ID.
		//
		// SECURITY CONSIDERATIONS:
		// - Requires the 'rbac.*.create_permission' permission on your root key
		// - Use carefully to avoid permission proliferation
		// - Consider centralizing permission creation in a controlled process
		// - Typos with create=true can lead to unintended permissions
		// - Created permissions are permanent and visible to all API keys in the workspace
		Create *bool `json:"create,omitempty"`

		// Id The ID of an existing permission (begins with 'perm_'). Provide either ID or name. Use ID when you know the exact permission identifier and want to ensure you're referencing a specific permission.
		Id *string `json:"id,omitempty"`

		// Name The name of the permission. Provide either ID or name. Permission names typically follow a 'resource.action' format (e.g., 'documents.read', 'users.delete'). Use consistent naming patterns to create logical permission hierarchies.
		Name *string `json:"name,omitempty"`
	} `json:"permissions"`
}

// V2KeysAddPermissionsResponse defines model for V2KeysAddPermissionsResponse.
type V2KeysAddPermissionsResponse struct {
	// Data Complete list of all permissions directly assigned to the key (including both newly added permissions and those that were already assigned).
	//
	// This response includes:
	// - All direct permissions assigned to the key (both pre-existing and newly added)
	// - Permissions sorted alphabetically by name for consistent response format
	// - Both the permission ID and name for each permission
	//
	// Important notes:
	// - This list does NOT include permissions granted through roles
	// - For a complete permission picture, use /v2/keys.getKey instead
	// - An empty array indicates the key has no direct permissions assigned
	// - Only includes direct permissions from the same workspace as the key
	Data V2KeysAddPermissionsResponseData `json:"data"`
	Meta Meta                             `json:"meta"`
}

// V2KeysAddPermissionsResponseData Complete list of all permissions directly assigned to the key (including both newly added permissions and those that were already assigned).
//
// This response includes:
// - All direct permissions assigned to the key (both pre-existing and newly added)
// - Permissions sorted alphabetically by name for consistent response format
// - Both the permission ID and name for each permission
//
// Important notes:
// - This list does NOT include permissions granted through roles
// - For a complete permission picture, use /v2/keys.getKey instead
// - An empty array indicates the key has no direct permissions assigned
// - Only includes direct permissions from the same workspace as the key
type V2KeysAddPermissionsResponseData = []struct {
	// Id The unique identifier of the permission (begins with 'perm_'). This ID can be used in other API calls to reference this specific permission. IDs are guaranteed unique and won't change, making them ideal for scripting and automation. You can store these IDs in your system for consistent reference.
	Id string `json:"id"`

	// Name The name of the permission, typically following a 'resource.action' pattern like 'documents.read'. Names are human-readable identifiers used both for assignment and verification.
	//
	// During verification:
	// - The exact name is matched (e.g., 'documents.read')
	// - Hierarchical wildcards are supported in verification requests
	// - A key with permission 'documents.*' grants access to 'documents.read', 'documents.write', etc.
	// - Wildcards can appear at any level: 'billing.*.view' matches 'billing.invoices.view' and 'billing.payments.view'
	//
	// However, when adding permissions, you must specify each exact permission - wildcards are not valid for assignment.
	Name string `json:"name"`
}

// V2KeysAddRolesRequestBody defines model for V2KeysAddRolesRequestBody.
type V2KeysAddRolesRequestBody struct {
	// KeyId The ID of the key to which roles will be added (begins with 'key_'). This is the database reference ID for the key, not the actual API key string. This ID uniquely identifies which key will receive the additional roles.
	KeyId string `json:"keyId"`

	// Roles List of roles to add to the key. Each role can be identified by ID or name (if both are provided in the same object, ID takes precedence).
	//
	// Key behaviors:
	// - Duplicate roles are automatically handled (adding the same role twice has no effect)
	// - The operation is idempotent - running it multiple times produces the same result
	// - Roles must already exist - unlike permissions, roles cannot be created on-the-fly
	// - All roles must belong to the same workspace as the key
	// - Invalid roles will cause the entire operation to fail (atomic transaction)
	//
	// Roles are collections of permissions that provide a convenient way to assign multiple permissions at once. When a key is verified, all permissions granted through all assigned roles are checked, alongside any direct permissions on the key.
	Roles []struct {
		// Id The ID of an existing role (begins with 'role_'). Provide either ID or name, not both. Using the ID guarantees you're referencing the exact role intended, regardless of name changes. This is particularly valuable for scripting, automation, and ensuring consistency between environments where role names might differ but IDs are stable references.
		Id *string `json:"id,omitempty"`

		// Name The name of the role. Provide either ID or name, not both. Role names must be unique within a workspace, making them generally safe to use as references. Names are more human-readable and easier to work with in configurations and documentation. However, if roles are renamed, any integration using name references will need to be updated.
		Name *string `json:"name,omitempty"`
	} `json:"roles"`
}

// V2KeysAddRolesResponse defines model for V2KeysAddRolesResponse.
type V2KeysAddRolesResponse struct {
	// Data Complete list of all roles directly assigned to the key after the operation completes.
	//
	// The response includes:
	// - All roles now assigned to the key (both pre-existing and newly added)
	// - Both ID and name of each role for easy reference
	// - Roles sorted alphabetically by name for consistent response format
	//
	// Important notes:
	// - The response shows the complete current state after the addition
	// - An empty array means the key has no roles assigned (unlikely after an add operation)
	// - This only shows direct role assignments, not inherited or nested roles
	// - Role permissions are not expanded in this response - use keys.getKey for full details
	// - All role changes are logged in the audit log for security tracking
	Data V2KeysAddRolesResponseData `json:"data"`
	Meta Meta                       `json:"meta"`
}

// V2KeysAddRolesResponseData Complete list of all roles directly assigned to the key after the operation completes.
//
// The response includes:
// - All roles now assigned to the key (both pre-existing and newly added)
// - Both ID and name of each role for easy reference
// - Roles sorted alphabetically by name for consistent response format
//
// Important notes:
// - The response shows the complete current state after the addition
// - An empty array means the key has no roles assigned (unlikely after an add operation)
// - This only shows direct role assignments, not inherited or nested roles
// - Role permissions are not expanded in this response - use keys.getKey for full details
// - All role changes are logged in the audit log for security tracking
type V2KeysAddRolesResponseData = []struct {
	// Id The unique identifier of the role (begins with 'role_'). This ID can be used in other API calls to reference this specific role. Role IDs are immutable and guaranteed to be unique within your Unkey workspace, making them reliable reference points for integration and automation systems.
	Id string `json:"id"`

	// Name The name of the role. This is a human-readable identifier that's unique within your workspace. Role names help identify what access level or function a role provides. Common patterns include naming by access level ('admin', 'editor', 'viewer'), by department ('billing_manager', 'support_agent'), or by feature area ('analytics_user', 'dashboard_admin').
	Name string `json:"name"`
}

// V2KeysCreateKeyRequestBody defines model for V2KeysCreateKeyRequestBody.
type V2KeysCreateKeyRequestBody struct {
	// ApiId The API ID where this key should be created. Keys are isolated by API, preventing keys from one environment (e.g., development) being used in another (e.g., production). We recommend creating separate APIs for different environments and services.
	ApiId string `json:"apiId"`

	// ByteLength Controls the cryptographic strength of the generated key. Higher values increase security but result in longer keys. The default (16 bytes) provides 2^128 possible combinations, which is secure for most applications. For highly sensitive APIs, consider using 24 or 32 bytes.
	ByteLength *int `json:"byteLength,omitempty"`

	// Credits Usage limits configuration for this key. Credits provide a way to limit how many times a key can be used, with optional automatic refills. Unlike rate limits (which control frequency), credits control total usage and are globally consistent. This makes them ideal for implementing usage-based pricing, subscription tiers, or hard usage caps.
	Credits *struct {
		// Refill Configuration for automatic credit refills. This creates a subscription-like recurring quota that resets on a schedule. To implement monthly plans with usage quotas, set interval='monthly' with the appropriate amount and refillDay.
		Refill *struct {
			// Amount Number of credits to add during each automatic refill. This should typically match the 'remaining' value to provide consistent quota periods.
			Amount int `json:"amount"`

			// Interval How frequently credits should be automatically refilled. With 'daily', credits reset at midnight UTC. With 'monthly', credits reset on the specified refillDay (or the 1st if not specified).
			Interval V2KeysCreateKeyRequestBodyCreditsRefillInterval `json:"interval"`

			// RefillDay For monthly refills, the day of month when credits are replenished. If the month doesn't have this day (e.g., refillDay=31 in February), the refill occurs on the last day of the month.
			RefillDay *int `json:"refillDay,omitempty"`
		} `json:"refill,omitempty"`

		// Remaining The initial number of credits (or requests) this key can use before becoming invalid. Each verification decrements this counter by the specified cost (default 1). When it reaches zero, verification fails with code=USAGE_EXCEEDED. This provides global consistency for usage limits, making it ideal for paid APIs with strict quotas.
		Remaining int32 `json:"remaining"`
	} `json:"credits,omitempty"`

	// Enabled Controls whether the key is active upon creation. If false, verification will immediately fail with code=DISABLED. This is useful for preparing keys in advance that will be activated later, or for implementing approval workflows where keys are created disabled until reviewed.
	Enabled *bool `json:"enabled,omitempty"`

	// Expires Unix timestamp (milliseconds) when this key should automatically expire. After this time, verification will fail with code=EXPIRED. Use temporary keys for time-limited access, trial periods, emergency access, or one-time operations. Omit this field for keys that should never expire.
	Expires *int64 `json:"expires,omitempty"`

	// ExternalId Your system's unique identifier for the user or entity this key belongs to. This ID is returned during verification, allowing you to identify the key owner without additional database lookups. Typically, this should be your user ID, organization ID, or tenant ID - whatever you use to identify entities in your system.
	ExternalId *string `json:"externalId,omitempty"`

	// Meta Arbitrary JSON metadata stored with the key and returned during verification. This is ideal for contextual information needed during API requests like subscription plans, feature flags, or user properties. Storing this data with the key eliminates the need for additional database lookups during verification, improving performance for stateless services.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name Human-readable name for the key shown in dashboards, logs, and API responses. This helps identify the key's purpose or owner but is never exposed to end users. Good names include the user's name, the specific service, or the access level (e.g., 'Alice's Production Key', 'Payment Service Key', 'Admin Access').
	Name *string `json:"name,omitempty"`

	// Permissions Individual permissions to assign directly to this key. Permissions define specific actions the key can perform when verified with the permissions check. Use a hierarchical naming pattern like 'resource.action' (e.g., 'documents.read', 'users.delete') to create logical groupings. During verification, a key with permission 'documents.*' will have access to both 'documents.read' and 'documents.write'.
	Permissions *[]string `json:"permissions,omitempty"`

	// Prefix Optional prefix for the key that helps visually identify its purpose. The prefix becomes part of the key (e.g., 'prod_xxxxxxxxx') and appears in logs and dashboards. Use prefixes like 'prod', 'dev', 'test', or application names to help users understand what the key is for. Only alphanumeric characters, underscores, and hyphens are allowed.
	Prefix *string `json:"prefix,omitempty"`

	// Ratelimits Array of rate limits to apply to this key. Rate limits protect against abuse by controlling how frequently operations can be performed. Unlike credits (which limit total usage), rate limits are time-based and automatically reset. They're optimized for performance and typically add minimal latency to verifications.
	Ratelimits *[]struct {
		// Duration Duration of the rate limit window in milliseconds. Common durations include 60000 (1 minute), 3600000 (1 hour), or 86400000 (1 day). The rate limit resets after this period has elapsed.
		Duration int32 `json:"duration"`

		// Limit Maximum number of operations allowed within the time window. When this limit is reached, verification fails with code=RATE_LIMITED until the window resets.
		Limit int32 `json:"limit"`

		// Name Identifier for this rate limit. Multiple named rate limits can control different aspects of API usage. Use descriptive names that reflect what's being limited, like 'requests', 'compute_operations', or 'database_writes'.
		Name string `json:"name"`
	} `json:"ratelimits,omitempty"`

	// Recoverable If true, the plaintext key is stored in an encrypted vault, allowing it to be retrieved later using keys.getKey with decrypt=true. SECURITY WARNING: This reduces security by storing the key in recoverable format. Use only for development keys, emergency backup, or when absolutely necessary. In production, set this to false (default) for maximum security.
	Recoverable *bool `json:"recoverable,omitempty"`

	// Roles Roles to assign to this key for permission management. Each role represents a collection of permissions that define what actions the key can perform. Roles must already exist in your workspace. During verification, all permissions from these roles are checked against requested permissions. Common role names include 'admin', 'editor', 'viewer', etc.
	Roles *[]string `json:"roles,omitempty"`
}

// V2KeysCreateKeyRequestBodyCreditsRefillInterval How frequently credits should be automatically refilled. With 'daily', credits reset at midnight UTC. With 'monthly', credits reset on the specified refillDay (or the 1st if not specified).
type V2KeysCreateKeyRequestBodyCreditsRefillInterval string

// V2KeysCreateKeyResponseBody defines model for V2KeysCreateKeyResponseBody.
type V2KeysCreateKeyResponseBody struct {
	Data KeysCreateKeyResponseData `json:"data"`
	Meta Meta                      `json:"meta"`
}

// V2KeysDeleteKeyRequestBody defines model for V2KeysDeleteKeyRequestBody.
type V2KeysDeleteKeyRequestBody struct {
	// KeyId The unique identifier of the key to delete (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. Once deleted, verification attempts with this key will fail with code=NOT_FOUND and it will no longer appear in key listings.
	KeyId string `json:"keyId"`

	// Permanent Controls whether the key should be soft-deleted (default) or permanently erased from the database. Soft deletion marks the key as deleted but preserves its data, allowing potential recovery via direct database operations. Permanent deletion completely removes all traces of the key including its hash and metadata. Use permanent=true for regulatory compliance scenarios (like GDPR), resolving hash collisions during migrations, or when you need to reuse the same key string in the future. CAUTION: Permanent deletion cannot be undone.
	Permanent *bool `json:"permanent,omitempty"`
}

// V2KeysDeleteKeyResponseBody defines model for V2KeysDeleteKeyResponseBody.
type V2KeysDeleteKeyResponseBody struct {
	// Data Empty response object. A successful response indicates the key was deleted successfully. Deletion triggers cache invalidation across all regions, but it may take up to 30 seconds for the deletion to be fully propagated due to eventual consistency. During this propagation period, some verification attempts might still succeed in certain regions.
	Data *KeysDeleteKeyResponseData `json:"data,omitempty"`
	Meta Meta                       `json:"meta"`
}

// V2KeysGetKeyRequestBody defines model for V2KeysGetKeyRequestBody.
type V2KeysGetKeyRequestBody struct {
	// Decrypt Whether to include the plaintext key in the response. This is only possible for keys created with 'recoverable: true' and requires the 'decrypt_key' permission. SECURITY WARNING: This should be used sparingly and only for legitimate recovery purposes. Keys returned this way must be handled securely and not logged or stored insecurely. Most applications should set this to false.
	Decrypt *bool `json:"decrypt,omitempty"`

	// KeyId The unique identifier of the key to retrieve (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. You can find this ID in the creation response, key listings, or in the dashboard.
	KeyId string `json:"keyId"`
}

// V2KeysGetKeyResponseBody defines model for V2KeysGetKeyResponseBody.
type V2KeysGetKeyResponseBody struct {
	Data KeysGetKeyResponseData `json:"data"`
	Meta Meta                   `json:"meta"`
}

// V2KeysRemovePermissionsRequestBody defines model for V2KeysRemovePermissionsRequestBody.
type V2KeysRemovePermissionsRequestBody struct {
	// KeyId The unique identifier of the key from which permissions will be removed (begins with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. Every operation requires this identifier to specify which key to modify.
	KeyId string `json:"keyId"`

	// Permissions List of permissions to remove from the key. Each permission can be identified by ID or name (if both are provided in the same object, ID takes precedence).
	//
	// Important details:
	// - This operation only affects direct permissions on the key, not permissions granted through roles
	// - Removing permissions that aren't assigned to the key is a no-op and doesn't cause an error
	// - Removing all permissions doesn't disable the key - it just removes its direct permissions
	// - The operation is idempotent - multiple identical requests have the same effect as a single request
	// - After removal, any verification checks for these permissions will fail unless granted via roles
	// - Each permission must include either id or name - you can't use wildcards for removal
	Permissions []struct {
		// Id The ID of the permission to remove (begins with 'perm_'). Provide either ID or name, not both. Using ID guarantees you're removing the exact permission intended, even if multiple permissions have similar names. The ID is especially useful in automation scripts where precision is important.
		Id *string `json:"id,omitempty"`

		// Name The name of the permission to remove. Provide either ID or name, not both. When using names, the string must match exactly as it was defined - including case sensitivity and full hierarchical path (e.g., 'documents.write', not just 'write'). Name lookup happens within the same workspace as the key.
		Name *string `json:"name,omitempty"`
	} `json:"permissions"`
}

// V2KeysRemovePermissionsResponse defines model for V2KeysRemovePermissionsResponse.
type V2KeysRemovePermissionsResponse struct {
	// Data Empty response object by design. A successful response indicates the permissions were successfully removed from the key. Unlike the addPermissions endpoint which returns the current permissions, this endpoint returns an empty object to reduce response size.
	//
	// Important post-operation effects:
	// - Any cached versions of the key are immediately invalidated to ensure consistency
	// - Changes to permissions take effect within seconds for new verifications
	// - Existing verification sessions might retain permissions until their cache expires (usually <30 seconds)
	// - To get the updated list of permissions, use the keys.getKey endpoint
	// - All permission removals are logged to the audit log for security tracking
	Data V2KeysRemovePermissionsResponseData `json:"data"`
	Meta Meta                                `json:"meta"`
}

// V2KeysRemovePermissionsResponseData Empty response object by design. A successful response indicates the permissions were successfully removed from the key. Unlike the addPermissions endpoint which returns the current permissions, this endpoint returns an empty object to reduce response size.
//
// Important post-operation effects:
// - Any cached versions of the key are immediately invalidated to ensure consistency
// - Changes to permissions take effect within seconds for new verifications
// - Existing verification sessions might retain permissions until their cache expires (usually <30 seconds)
// - To get the updated list of permissions, use the keys.getKey endpoint
// - All permission removals are logged to the audit log for security tracking
type V2KeysRemovePermissionsResponseData = map[string]interface{}

// V2KeysRemoveRolesRequestBody defines model for V2KeysRemoveRolesRequestBody.
type V2KeysRemoveRolesRequestBody struct {
	// KeyId The ID of the key from which roles will be removed (begins with 'key_'). This is the database reference for the key, not the actual API key string that users authenticate with. Every operation requires this identifier to specify which key to modify.
	KeyId string `json:"keyId"`

	// Roles List of roles to remove from the key. Each role can be identified by ID or name (if both are provided in the same object, ID takes precedence).
	//
	// Key behaviors:
	// - Only affects direct role assignments on the key
	// - Removing roles that aren't assigned to the key has no effect (silent no-op)
	// - The operation is idempotent - multiple identical requests have the same effect
	// - Invalid role references will cause the entire operation to fail (atomic transaction)
	// - After removal, the key will lose access to any permissions that were only granted through these roles
	// - Inherited roles or permissions from other sources are not affected
	//
	// This operation is commonly used when downgrading access levels, removing temporary elevated privileges, or fine-tuning access control for API keys.
	Roles []struct {
		// Id The ID of an existing role (begins with 'role_'). Provide either ID or name, not both. Using the role ID ensures you're removing exactly the intended role, even if multiple roles have similar or identical names. IDs are especially useful in automation scripts and cross-environment scenarios where consistent references are important.
		Id *string `json:"id,omitempty"`

		// Name The name of the role. Provide either ID or name, not both. Role names must exactly match the role's current name in your workspace, including case sensitivity. Names are more human-readable and easier to work with in configurations, but if roles are renamed, any systems using name references will need to be updated.
		Name *string `json:"name,omitempty"`
	} `json:"roles"`
}

// V2KeysRemoveRolesResponse defines model for V2KeysRemoveRolesResponse.
type V2KeysRemoveRolesResponse struct {
	// Data Complete list of all roles directly assigned to the key after the removal operation completes.
	//
	// The response includes:
	// - The remaining roles still assigned to the key (after removing the specified roles)
	// - Both ID and name for each role for easy reference
	// - Roles sorted alphabetically by name for consistent response format
	//
	// Important notes:
	// - The response reflects the current state after the removal operation
	// - An empty array indicates the key now has no roles assigned
	// - This only shows direct role assignments
	// - Role permissions are not expanded in this response - use keys.getKey for full details
	// - All role changes are logged in the audit log for security tracking
	// - Changes take effect immediately for new verifications but cached sessions may retain old permissions briefly
	Data V2KeysRemoveRolesResponseData `json:"data"`
	Meta Meta                          `json:"meta"`
}

// V2KeysRemoveRolesResponseData Complete list of all roles directly assigned to the key after the removal operation completes.
//
// The response includes:
// - The remaining roles still assigned to the key (after removing the specified roles)
// - Both ID and name for each role for easy reference
// - Roles sorted alphabetically by name for consistent response format
//
// Important notes:
// - The response reflects the current state after the removal operation
// - An empty array indicates the key now has no roles assigned
// - This only shows direct role assignments
// - Role permissions are not expanded in this response - use keys.getKey for full details
// - All role changes are logged in the audit log for security tracking
// - Changes take effect immediately for new verifications but cached sessions may retain old permissions briefly
type V2KeysRemoveRolesResponseData = []struct {
	// Id The unique identifier of the role (begins with 'role_'). This ID can be used in other API calls to reference this specific role.
	Id string `json:"id"`

	// Name The name of the role. This is a human-readable identifier that's unique within your workspace.
	Name string `json:"name"`
}

// V2KeysSetPermissionsRequestBody defines model for V2KeysSetPermissionsRequestBody.
type V2KeysSetPermissionsRequestBody struct {
	// KeyId The unique identifier of the key to set permissions on (begins with 'key_'). This ID comes from the createKey response and identifies which key will have its permissions replaced. This is the database ID, not the actual API key string that users authenticate with.
	KeyId string `json:"keyId"`

	// Permissions The permissions to set for this key. This is a complete replacement operation - it overwrites all existing direct permissions with this new set.
	//
	// Key behaviors:
	// - Providing an empty array removes all direct permissions from the key
	// - This only affects direct permissions - permissions granted through roles are not affected
	// - All existing direct permissions not included in this list will be removed
	// - The complete list approach allows synchronizing permissions with external systems
	// - Permission changes take effect immediately for new verifications
	//
	// Unlike addPermissions (which only adds) or removePermissions (which only removes), this endpoint performs a wholesale replacement of the permission set.
	Permissions []struct {
		// Create When true, if a permission with this name doesn't exist, it will be automatically created on-the-fly. Only works when specifying name, not ID.
		//
		// SECURITY CONSIDERATIONS:
		// - Requires the 'rbac.*.create_permission' permission on your root key
		// - Created permissions are permanent and visible throughout your workspace
		// - Use carefully to avoid permission proliferation and inconsistency
		// - Consider using a controlled process for permission creation instead
		// - Typos with create=true will create unintended permissions that persist in your system
		Create *bool `json:"create,omitempty"`

		// Id The ID of an existing permission (begins with 'perm_'). Provide either ID or name for each permission, not both. Using ID is more precise and guarantees you're referencing the exact permission intended, regardless of name changes or duplicates. IDs are particularly useful in automation scripts and when migrating permissions between environments.
		Id *string `json:"id,omitempty"`

		// Name The name of the permission. Provide either ID or name for each permission, not both. Names must match exactly as defined in your permission system - including case sensitivity and the complete hierarchical path. Names are generally more human-readable but can be ambiguous if not carefully managed across your workspace.
		Name *string `json:"name,omitempty"`
	} `json:"permissions"`
}

// V2KeysSetPermissionsResponse defines model for V2KeysSetPermissionsResponse.
type V2KeysSetPermissionsResponse struct {
	// Data Complete list of all permissions now directly assigned to the key after the set operation has completed.
	//
	// The response includes:
	// - The comprehensive, updated set of direct permissions (reflecting the complete replacement)
	// - Both ID and name for each permission for easy reference
	// - Permissions sorted alphabetically by name for consistent response format
	//
	// Important notes:
	// - This only shows direct permissions, not those granted through roles
	// - An empty array means the key has no direct permissions assigned
	// - For a complete permission picture including roles, use keys.getKey instead
	// - All permission changes are logged in the audit log for security tracking
	Data V2KeysSetPermissionsResponseData `json:"data"`
	Meta Meta                             `json:"meta"`
}

// V2KeysSetPermissionsResponseData Complete list of all permissions now directly assigned to the key after the set operation has completed.
//
// The response includes:
// - The comprehensive, updated set of direct permissions (reflecting the complete replacement)
// - Both ID and name for each permission for easy reference
// - Permissions sorted alphabetically by name for consistent response format
//
// Important notes:
// - This only shows direct permissions, not those granted through roles
// - An empty array means the key has no direct permissions assigned
// - For a complete permission picture including roles, use keys.getKey instead
// - All permission changes are logged in the audit log for security tracking
type V2KeysSetPermissionsResponseData = []struct {
	// Id The unique identifier of the permission
	Id string `json:"id"`

	// Name The name of the permission
	Name string `json:"name"`
}

// V2KeysSetRolesRequestBody defines model for V2KeysSetRolesRequestBody.
type V2KeysSetRolesRequestBody struct {
	// KeyId The ID of the key for which to set roles (begins with 'key_'). This is the database reference ID for the key, not the actual API key string. This operation will replace all existing direct role assignments for this key.
	KeyId string `json:"keyId"`

	// Roles Complete list of roles to assign to the key. This is a wholesale replacement operation - it replaces all existing direct role assignments with this new set.
	//
	// Key behaviors:
	// - This operation is a complete replacement, not an incremental update
	// - Any existing roles not included in this request will be removed
	// - Providing an empty array removes all direct role assignments from the key
	// - Roles must already exist - they cannot be created on-the-fly like permissions
	// - All roles must belong to the same workspace as the key
	// - Invalid role references will cause the entire operation to fail (atomic transaction)
	// - Changes take effect immediately for new verifications
	//
	// This approach allows you to precisely control the full role set in a single operation, making it ideal for synchronizing roles with external systems or implementing controlled role templates.
	Roles []struct {
		// Id The ID of an existing role (begins with 'role_'). Provide either ID or name, not both. Using role IDs guarantees you're referencing the exact roles intended, regardless of name changes or duplications. This approach is particularly valuable in automation scripts, cross-environment deployments, and systems where role names might change but IDs remain stable.
		Id *string `json:"id,omitempty"`

		// Name The name of the role. Provide either ID or name, not both. Role names must be unique within a workspace, making them generally safe to use as references. Names are more human-readable and easier to work with in configurations, especially when implementing standardized role templates across many keys. However, if roles are renamed, any integrations using name references will need updates.
		Name *string `json:"name,omitempty"`
	} `json:"roles"`
}

// V2KeysSetRolesResponse defines model for V2KeysSetRolesResponse.
type V2KeysSetRolesResponse struct {
	// Data Complete list of all roles now directly assigned to the key after the set operation has completed.
	//
	// The response includes:
	// - The comprehensive, updated set of roles (reflecting the complete replacement)
	// - Both ID and name for each role for easy reference
	// - Roles sorted alphabetically by name for consistent response format
	//
	// Important notes:
	// - This response shows the final state after the complete replacement
	// - If you provided an empty array in the request, this will also be empty
	// - This only shows direct role assignments on the key
	// - Role permissions are not expanded in this response - use keys.getKey for complete details
	// - All role changes are logged in the audit log for security tracking
	// - An empty array indicates the key now has no roles assigned at all
	Data V2KeysSetRolesResponseData `json:"data"`
	Meta Meta                       `json:"meta"`
}

// V2KeysSetRolesResponseData Complete list of all roles now directly assigned to the key after the set operation has completed.
//
// The response includes:
// - The comprehensive, updated set of roles (reflecting the complete replacement)
// - Both ID and name for each role for easy reference
// - Roles sorted alphabetically by name for consistent response format
//
// Important notes:
// - This response shows the final state after the complete replacement
// - If you provided an empty array in the request, this will also be empty
// - This only shows direct role assignments on the key
// - Role permissions are not expanded in this response - use keys.getKey for complete details
// - All role changes are logged in the audit log for security tracking
// - An empty array indicates the key now has no roles assigned at all
type V2KeysSetRolesResponseData = []struct {
	// Id The unique identifier of the role (begins with 'role_'). This ID can be used in other API calls to reference this specific role. Role IDs are immutable and guaranteed to be unique, making them reliable reference points for integration and automation systems.
	Id string `json:"id"`

	// Name The name of the role. This is a human-readable identifier that's unique within your workspace. Role names are descriptive labels that help identify what access level or function a role provides. Good naming practices include naming by access level ('admin', 'editor'), by department ('billing_team', 'support_staff'), or by feature area ('reporting_user', 'settings_manager').
	Name string `json:"name"`
}

// V2KeysUpdateKeyRequestBody defines model for V2KeysUpdateKeyRequestBody.
type V2KeysUpdateKeyRequestBody struct {
	// Credits Usage limits configuration for this key. Set to null to disable usage limits entirely (unlimited usage). Omit this field to leave all usage limit settings unchanged. Note: Cannot set refill when credits is null; setting refillDay requires interval to be 'monthly'. Use this to implement usage-based pricing models or to apply different quotas for different subscription tiers.
	Credits nullable.Nullable[struct {
		// Refill Configuration for automatic credit refills. Set to null to disable automatic refills (creating a one-time credit allocation). Omit this field to leave existing refill settings unchanged. Use refills to implement recurring quotas that reset on a schedule.
		Refill nullable.Nullable[struct {
			// Amount Number of credits to add during each automatic refill. This typically matches your plan's quota (e.g., 1000 API calls per month).
			Amount int `json:"amount"`

			// Interval How often the credits should be refilled. For 'monthly' refills, you can specify the day of month using 'refillDay'. Use 'daily' for high-frequency use cases (e.g., 100 requests per day) and 'monthly' for subscription-based models.
			Interval V2KeysUpdateKeyRequestBodyCreditsRefillInterval `json:"interval"`

			// RefillDay For monthly refills, the day of month when refills occur. Cannot be used with 'daily' interval. Useful for aligning quota refills with billing cycles or subscription renewal dates.
			RefillDay *int `json:"refillDay,omitempty"`
		}] `json:"refill,omitempty"`

		// Remaining Number of times this key can be used before becoming invalid. Required when specifying credits. Use this to implement usage-based pricing, subscription tiers, or consumption quotas. Each verification reduces this count by the verification cost (default 1).
		Remaining int32 `json:"remaining"`
	}] `json:"credits,omitempty"`

	// Enabled Whether the key is currently active. When set to false, verification attempts will fail with code=DISABLED. This allows temporarily suspending access without deleting the key, which is useful for pausing subscriptions, handling account issues, or during maintenance. Omit this field to leave the enabled status unchanged.
	Enabled *bool `json:"enabled,omitempty"`

	// Expires Unix timestamp (in milliseconds) when this key will automatically expire. After this time, verification will fail with code=EXPIRED. Set to null to remove an expiration date (making the key permanent). Omit this field to leave it unchanged. Useful for extending trials, adjusting subscription periods, or implementing temporary access.
	Expires nullable.Nullable[int64] `json:"expires,omitempty"`

	// ExternalId Your user's unique identifier, creating a link between Unkey and your system. This helps identify which user/entity owns this key during verification. Set to null to disconnect this key from any identity. Omit this field to leave it unchanged. Useful when transferring keys between users or when a user's ID changes in your system.
	ExternalId nullable.Nullable[string] `json:"externalId,omitempty"`

	// KeyId The unique identifier of the key to update (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. Always required for any update operation.
	KeyId string `json:"keyId"`

	// Meta Arbitrary JSON metadata to associate with this key. This data is returned during key verification and can be used to store anything needed during API access: subscription plans, feature flags, user properties, etc. Set to null to remove all metadata. Omit this field to leave it unchanged. This lets you update user context without having to issue new keys.
	Meta nullable.Nullable[map[string]interface{}] `json:"meta,omitempty"`

	// Name A descriptive name for the key for internal reference. Set to null to remove the name. Omit this field to leave it unchanged. Good naming helps with key organization, especially when managing many keys for different users or services.
	Name nullable.Nullable[string] `json:"name,omitempty"`

	// Ratelimits Array of rate limits to apply to this key. Rate limits provide protection against abuse by controlling request frequency. Set to null to remove all rate limits. Omit this field to leave existing rate limits unchanged. Unlike credits (which limit total usage), rate limits are time-based and automatically reset. You can define multiple named rate limits to control different aspects of API usage with different thresholds and time windows.
	Ratelimits nullable.Nullable[[]struct {
		// Async Whether this rate limit uses fast (async=true) or consistent (async=false) mode. Fast mode has lower latency but less accuracy, making it suitable for most use cases. Consistent mode provides stronger guarantees but adds latency to verifications. Use consistent mode only when strict rate limiting is essential.
		Async *bool `json:"async,omitempty"`

		// Duration Duration of the rate limit window in milliseconds. Common values include 60000 (1 minute), 3600000 (1 hour), and 86400000 (24 hours). The rate limit automatically resets after this period elapses.
		Duration int32 `json:"duration"`

		// Limit Maximum number of operations allowed within the time window. When this limit is reached, verification fails with code=RATE_LIMITED until the window resets. Adjust this based on your API's capacity and the user's expected usage patterns.
		Limit int32 `json:"limit"`

		// Name Identifier for this rate limit. Names must be unique for this key. Use semantic names reflecting what's being limited, such as 'requests' (overall API calls), 'computations' (intensive operations), or 'write_operations' (data-modifying calls).
		Name string `json:"name"`
	}] `json:"ratelimits,omitempty"`
}

// V2KeysUpdateKeyRequestBodyCreditsRefillInterval How often the credits should be refilled. For 'monthly' refills, you can specify the day of month using 'refillDay'. Use 'daily' for high-frequency use cases (e.g., 100 requests per day) and 'monthly' for subscription-based models.
type V2KeysUpdateKeyRequestBodyCreditsRefillInterval string

// V2KeysUpdateKeyResponseBody defines model for V2KeysUpdateKeyResponseBody.
type V2KeysUpdateKeyResponseBody struct {
	// Data Empty response object by design. A successful response indicates the key was updated successfully. The endpoint doesn't return the updated key to reduce response size and avoid exposing sensitive information. Changes may take up to 30 seconds to propagate to all regions due to cache invalidation delays. If you need the updated key state, use a subsequent call to keys.getKey.
	Data *KeysUpdateKeyResponseData `json:"data,omitempty"`
	Meta Meta                       `json:"meta"`
}

// V2KeysUpdateRemainingRequestBody defines model for V2KeysUpdateRemainingRequestBody.
type V2KeysUpdateRemainingRequestBody struct {
	// KeyId The ID of the key to update (begins with 'key_'). This is the database reference ID for the key, not the actual API key string that users authenticate with. This ID uniquely identifies which key's credits will be updated.
	KeyId string `json:"keyId"`

	// OverwriteRefillSettings When true, any existing automatic refill settings will be removed from the key.
	//
	// Use cases:
	// - Convert a key with automatic periodic refills to a one-time credit allocation
	// - Remove subscription-like behavior in favor of manually controlled credits
	// - Downgrade from an automatic plan to a fixed allocation
	// - Simplify credit management by removing automated refills
	//
	// When false or omitted, existing refill settings are preserved, and only the current remaining value is updated. This lets you adjust the current balance without changing the refill schedule.
	OverwriteRefillSettings *bool `json:"overwriteRefillSettings,omitempty"`

	// Remaining The new value for the remaining credits. This is an absolute value replacement, not an increment or decrement operation.
	//
	// Key behaviors:
	// - This completely replaces the current remaining credits value
	// - To add credits, first get the current value and then set remaining = current + additional
	// - To make a key unlimited, set remaining = -1
	// - To make a key with unlimited usage have a specific limit, set remaining to a positive number
	// - Credits are decremented each time the key is successfully verified (by the cost value, default 1)
	// - When credits reach zero, verification fails with code=USAGE_EXCEEDED
	//
	// This field is useful for implementing usage-based pricing, subscription tiers, trial periods, or consumption quotas.
	Remaining int64 `json:"remaining"`
}

// V2KeysUpdateRemainingResponse defines model for V2KeysUpdateRemainingResponse.
type V2KeysUpdateRemainingResponse struct {
	Data KeysUpdateRemainingResponseData `json:"data"`
	Meta Meta                            `json:"meta"`
}

// V2KeysVerifyKeyRequestBody defines model for V2KeysVerifyKeyRequestBody.
type V2KeysVerifyKeyRequestBody struct {
	// ApiId The ID of the API this key belongs to. This is required to ensure keys from different environments (dev/staging/prod) or different services don't leak between contexts. You should store this API ID alongside your service configuration.
	ApiId string `json:"apiId"`

	// Credits Optional configuration for how this request should affect the key's remaining usage credits. Credits provide a globally consistent mechanism for limiting key usage, ideal for paid APIs with strict usage limits.
	Credits *struct {
		// Cost The number of credits to deduct for this verification. Set to 0 to validate the key without consuming credits (useful for read-only or free operations). Set higher for premium/expensive operations. This allows implementing tiered usage within a single API.
		Cost *int32 `json:"cost,omitempty"`
	} `json:"credits,omitempty"`

	// Key The API key to verify. This is the full string provided by your user - including any prefix. Unkey uses a secure hashing algorithm to verify the key without storing the plaintext value. SECURITY NOTICE: Never log or store API keys in your system.
	Key string `json:"key"`

	// Permissions Optional RBAC permission checks to verify the key has the required permissions. If provided, the verification will only succeed if the key has the specified permissions (either directly or through roles). This is the recommended way to implement authorization in your API.
	Permissions *V2KeysVerifyKeyRequestBody_Permissions `json:"permissions,omitempty"`

	// Ratelimits Optional array of ratelimits to check during verification. Ratelimits provide protection against abuse by limiting the frequency of operations. Multiple named ratelimits can be used to control different aspects of your API. Unlike credits, ratelimits are optimized for performance with eventual consistency.
	Ratelimits *[]struct {
		// Cost The cost of this operation against the ratelimit. Higher values consume more of the ratelimit quota. Use this to model operations with different weights.
		Cost *int32 `json:"cost,omitempty"`

		// Duration Temporarily override the ratelimit window duration in milliseconds for this request only. This won't change the stored configuration.
		Duration *int32 `json:"duration,omitempty"`

		// Limit Temporarily override the configured limit for this request only. This won't change the stored configuration.
		Limit *int32 `json:"limit,omitempty"`

		// Name The name of the ratelimit to check. This must match a ratelimit configured for the key or identity. Use semantic names like 'requests', 'computations', or 'heavy_operations'.
		Name string `json:"name"`
	} `json:"ratelimits,omitempty"`

	// Tags Optional metadata tags for analytics and monitoring. These don't affect verification outcomes but let you segment API usage in analytics dashboards. Good uses include tracking endpoints, client versions, regions, or request details. Format as 'key=value' for best compatibility with analytics tools.
	Tags *[]string `json:"tags,omitempty"`
}

// V2KeysVerifyKeyRequestBodyPermissions0 A single permission to check. The key is valid only if it has this exact permission. Permission checks are hierarchical - a key with permission 'documents.*' will have access to 'documents.read' and 'documents.write'.
type V2KeysVerifyKeyRequestBodyPermissions0 = string

// V2KeysVerifyKeyRequestBodyPermissions1 defines model for .
type V2KeysVerifyKeyRequestBodyPermissions1 struct {
	// Permissions List of permissions to check against the key's assigned permissions and roles.
	Permissions []string `json:"permissions"`

	// Type Logical operator to apply to the permissions. 'and' requires all permissions to be present, 'or' requires at least one.
	Type V2KeysVerifyKeyRequestBodyPermissions1Type `json:"type"`
}

// V2KeysVerifyKeyRequestBodyPermissions1Type Logical operator to apply to the permissions. 'and' requires all permissions to be present, 'or' requires at least one.
type V2KeysVerifyKeyRequestBodyPermissions1Type string

// V2KeysVerifyKeyRequestBody_Permissions Optional RBAC permission checks to verify the key has the required permissions. If provided, the verification will only succeed if the key has the specified permissions (either directly or through roles). This is the recommended way to implement authorization in your API.
type V2KeysVerifyKeyRequestBody_Permissions struct {
	union json.RawMessage
}

// V2KeysVerifyKeyResponseBody defines model for V2KeysVerifyKeyResponseBody.
type V2KeysVerifyKeyResponseBody struct {
	Data KeysVerifyKeyResponseData `json:"data"`
	Meta Meta                      `json:"meta"`
}

// V2KeysWhoamiRequestBody defines model for V2KeysWhoamiRequestBody.
type V2KeysWhoamiRequestBody struct {
	// Key The API key to identify and retrieve information about
	Key string `json:"key"`
}

// V2KeysWhoamiResponse defines model for V2KeysWhoamiResponse.
type V2KeysWhoamiResponse struct {
	Data KeyWhoamiData `json:"data"`
	Meta Meta          `json:"meta"`
}

// V2LivenessResponseBody defines model for V2LivenessResponseBody.
type V2LivenessResponseBody struct {
	Data LivenessResponseData `json:"data"`
	Meta Meta                 `json:"meta"`
}

// V2PermissionsCreatePermissionRequestBody defines model for V2PermissionsCreatePermissionRequestBody.
type V2PermissionsCreatePermissionRequestBody struct {
	// Description Explain what this permission does. This is just for your team, your users will not see this.
	Description *string `json:"description,omitempty"`

	// Name The unique name of your permission
	Name string `json:"name"`
}

// V2PermissionsCreatePermissionResponseBody defines model for V2PermissionsCreatePermissionResponseBody.
type V2PermissionsCreatePermissionResponseBody struct {
	Data PermissionsCreatePermissionResponseData `json:"data"`
	Meta Meta                                    `json:"meta"`
}

// V2PermissionsDeleteRoleRequestBody defines model for V2PermissionsDeleteRoleRequestBody.
type V2PermissionsDeleteRoleRequestBody struct {
	// RoleId The id of the role to delete
	RoleId string `json:"roleId"`
}

// V2PermissionsDeleteRoleResponseBody defines model for V2PermissionsDeleteRoleResponseBody.
type V2PermissionsDeleteRoleResponseBody struct {
	Meta Meta `json:"meta"`
}

// V2PermissionsGetPermissionRequestBody defines model for V2PermissionsGetPermissionRequestBody.
type V2PermissionsGetPermissionRequestBody struct {
	// PermissionId The id of the permission to retrieve
	PermissionId string `json:"permissionId"`
}

// V2PermissionsGetPermissionResponseBody defines model for V2PermissionsGetPermissionResponseBody.
type V2PermissionsGetPermissionResponseBody struct {
	Data PermissionsGetPermissionResponseData `json:"data"`
	Meta Meta                                 `json:"meta"`
}

// V2PermissionsListPermissionsRequestBody defines model for V2PermissionsListPermissionsRequestBody.
type V2PermissionsListPermissionsRequestBody struct {
	// Cursor Cursor for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of permissions to return
	Limit *int32 `json:"limit,omitempty"`
}

// V2PermissionsListPermissionsResponseBody defines model for V2PermissionsListPermissionsResponseBody.
type V2PermissionsListPermissionsResponseBody struct {
	Data PermissionsListPermissionsResponseData `json:"data"`
	Meta Meta                                   `json:"meta"`
}

// V2PermissionsListRolesRequestBody defines model for V2PermissionsListRolesRequestBody.
type V2PermissionsListRolesRequestBody struct {
	// Cursor Cursor for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of roles to return
	Limit *int32 `json:"limit,omitempty"`
}

// V2PermissionsListRolesResponseBody defines model for V2PermissionsListRolesResponseBody.
type V2PermissionsListRolesResponseBody struct {
	Data PermissionsListRolesResponseData `json:"data"`
	Meta Meta                             `json:"meta"`
}

// V2RatelimitDeleteOverrideRequestBody Deletes an existing override.
type V2RatelimitDeleteOverrideRequestBody struct {
	// Identifier Identifier of the override to delete
	Identifier string `json:"identifier"`

	// NamespaceId The id of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitDeleteOverrideResponseBody defines model for V2RatelimitDeleteOverrideResponseBody.
type V2RatelimitDeleteOverrideResponseBody struct {
	Data RatelimitDeleteOverrideResponseData `json:"data"`
	Meta Meta                                `json:"meta"`
}

// V2RatelimitGetOverrideRequestBody Gets the configuration of an existing override.
type V2RatelimitGetOverrideRequestBody struct {
	// Identifier Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( * ) can be used to match multiple identifiers, More info can be found at https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules
	Identifier string `json:"identifier"`

	// NamespaceId The id of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitGetOverrideResponseBody defines model for V2RatelimitGetOverrideResponseBody.
type V2RatelimitGetOverrideResponseBody struct {
	Data RatelimitOverride `json:"data"`
	Meta Meta              `json:"meta"`
}

// V2RatelimitLimitRequestBody defines model for V2RatelimitLimitRequestBody.
type V2RatelimitLimitRequestBody struct {
	// Cost The cost of the request. Defaults to 1 if not provided.
	Cost *int64 `json:"cost,omitempty"`

	// Duration The duration in milliseconds for the rate limit window.
	Duration int64 `json:"duration"`

	// Identifier The identifier for the rate limit.
	Identifier string `json:"identifier"`

	// Limit The maximum number of requests allowed.
	Limit int64 `json:"limit"`

	// Namespace The namespace name for the rate limit.
	Namespace string `json:"namespace"`
}

// V2RatelimitLimitResponseBody defines model for V2RatelimitLimitResponseBody.
type V2RatelimitLimitResponseBody struct {
	Data RatelimitLimitResponseData `json:"data"`
	Meta Meta                       `json:"meta"`
}

// V2RatelimitListOverridesRequestBody defines model for V2RatelimitListOverridesRequestBody.
type V2RatelimitListOverridesRequestBody struct {
	// Cursor Pagination cursor from a previous response
	Cursor *string `json:"cursor,omitempty"`

	// Limit Maximum number of results to return
	Limit *int `json:"limit,omitempty"`

	// NamespaceId The id of the namespace to list overrides for.
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the namespace to list overrides for.
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitListOverridesResponseBody defines model for V2RatelimitListOverridesResponseBody.
type V2RatelimitListOverridesResponseBody struct {
	Data       RatelimitListOverridesResponseData `json:"data"`
	Meta       Meta                               `json:"meta"`
	Pagination *Pagination                        `json:"pagination,omitempty"`
}

// V2RatelimitSetOverrideRequestBody Sets a new or overwrites an existing override.
type V2RatelimitSetOverrideRequestBody struct {
	// Duration The duration in milliseconds for the rate limit window.
	Duration int64 `json:"duration"`

	// Identifier Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( * ) can be used to match multiple identifiers, More info can be found at https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules
	Identifier string `json:"identifier"`

	// Limit The maximum number of requests allowed.
	Limit int64 `json:"limit"`

	// NamespaceId The id of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitSetOverrideResponseBody defines model for V2RatelimitSetOverrideResponseBody.
type V2RatelimitSetOverrideResponseBody struct {
	Data RatelimitSetOverrideResponseData `json:"data"`
	Meta Meta                             `json:"meta"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Fix A human-readable message describing how to fix the error.
	Fix *string `json:"fix,omitempty"`

	// Location Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
	Location string `json:"location"`

	// Message Error message text
	Message string `json:"message"`
}

// CreateApiJSONRequestBody defines body for CreateApi for application/json ContentType.
type CreateApiJSONRequestBody = V2ApisCreateApiRequestBody

// DeleteApiJSONRequestBody defines body for DeleteApi for application/json ContentType.
type DeleteApiJSONRequestBody = V2ApisDeleteApiRequestBody

// GetApiJSONRequestBody defines body for GetApi for application/json ContentType.
type GetApiJSONRequestBody = V2ApisGetApiRequestBody

// ListKeysJSONRequestBody defines body for ListKeys for application/json ContentType.
type ListKeysJSONRequestBody = V2ApisListKeysRequestBody

// IdentitiesCreateIdentityJSONRequestBody defines body for IdentitiesCreateIdentity for application/json ContentType.
type IdentitiesCreateIdentityJSONRequestBody = V2IdentitiesCreateIdentityRequestBody

// V2IdentitiesDeleteIdentityJSONRequestBody defines body for V2IdentitiesDeleteIdentity for application/json ContentType.
type V2IdentitiesDeleteIdentityJSONRequestBody = V2IdentitiesDeleteIdentityRequestBody

// AddPermissionsJSONRequestBody defines body for AddPermissions for application/json ContentType.
type AddPermissionsJSONRequestBody = V2KeysAddPermissionsRequestBody

// AddRolesJSONRequestBody defines body for AddRoles for application/json ContentType.
type AddRolesJSONRequestBody = V2KeysAddRolesRequestBody

// CreateKeyJSONRequestBody defines body for CreateKey for application/json ContentType.
type CreateKeyJSONRequestBody = V2KeysCreateKeyRequestBody

// DeleteKeyJSONRequestBody defines body for DeleteKey for application/json ContentType.
type DeleteKeyJSONRequestBody = V2KeysDeleteKeyRequestBody

// GetKeyJSONRequestBody defines body for GetKey for application/json ContentType.
type GetKeyJSONRequestBody = V2KeysGetKeyRequestBody

// RemovePermissionsJSONRequestBody defines body for RemovePermissions for application/json ContentType.
type RemovePermissionsJSONRequestBody = V2KeysRemovePermissionsRequestBody

// RemoveRolesJSONRequestBody defines body for RemoveRoles for application/json ContentType.
type RemoveRolesJSONRequestBody = V2KeysRemoveRolesRequestBody

// SetPermissionsJSONRequestBody defines body for SetPermissions for application/json ContentType.
type SetPermissionsJSONRequestBody = V2KeysSetPermissionsRequestBody

// SetRolesJSONRequestBody defines body for SetRoles for application/json ContentType.
type SetRolesJSONRequestBody = V2KeysSetRolesRequestBody

// UpdateKeyJSONRequestBody defines body for UpdateKey for application/json ContentType.
type UpdateKeyJSONRequestBody = V2KeysUpdateKeyRequestBody

// UpdateRemainingJSONRequestBody defines body for UpdateRemaining for application/json ContentType.
type UpdateRemainingJSONRequestBody = V2KeysUpdateRemainingRequestBody

// VerifyKeyJSONRequestBody defines body for VerifyKey for application/json ContentType.
type VerifyKeyJSONRequestBody = V2KeysVerifyKeyRequestBody

// WhoamiJSONRequestBody defines body for Whoami for application/json ContentType.
type WhoamiJSONRequestBody = V2KeysWhoamiRequestBody

// CreatePermissionJSONRequestBody defines body for CreatePermission for application/json ContentType.
type CreatePermissionJSONRequestBody = V2PermissionsCreatePermissionRequestBody

// DeleteRoleJSONRequestBody defines body for DeleteRole for application/json ContentType.
type DeleteRoleJSONRequestBody = V2PermissionsDeleteRoleRequestBody

// GetPermissionJSONRequestBody defines body for GetPermission for application/json ContentType.
type GetPermissionJSONRequestBody = V2PermissionsGetPermissionRequestBody

// ListPermissionsJSONRequestBody defines body for ListPermissions for application/json ContentType.
type ListPermissionsJSONRequestBody = V2PermissionsListPermissionsRequestBody

// ListRolesJSONRequestBody defines body for ListRoles for application/json ContentType.
type ListRolesJSONRequestBody = V2PermissionsListRolesRequestBody

// RatelimitDeleteOverrideJSONRequestBody defines body for RatelimitDeleteOverride for application/json ContentType.
type RatelimitDeleteOverrideJSONRequestBody = V2RatelimitDeleteOverrideRequestBody

// RatelimitGetOverrideJSONRequestBody defines body for RatelimitGetOverride for application/json ContentType.
type RatelimitGetOverrideJSONRequestBody = V2RatelimitGetOverrideRequestBody

// RatelimitLimitJSONRequestBody defines body for RatelimitLimit for application/json ContentType.
type RatelimitLimitJSONRequestBody = V2RatelimitLimitRequestBody

// RatelimitListOverridesJSONRequestBody defines body for RatelimitListOverrides for application/json ContentType.
type RatelimitListOverridesJSONRequestBody = V2RatelimitListOverridesRequestBody

// RatelimitSetOverrideJSONRequestBody defines body for RatelimitSetOverride for application/json ContentType.
type RatelimitSetOverrideJSONRequestBody = V2RatelimitSetOverrideRequestBody

// AsV2IdentitiesDeleteIdentityRequestBody0 returns the union data inside the V2IdentitiesDeleteIdentityRequestBody as a V2IdentitiesDeleteIdentityRequestBody0
func (t V2IdentitiesDeleteIdentityRequestBody) AsV2IdentitiesDeleteIdentityRequestBody0() (V2IdentitiesDeleteIdentityRequestBody0, error) {
	var body V2IdentitiesDeleteIdentityRequestBody0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2IdentitiesDeleteIdentityRequestBody0 overwrites any union data inside the V2IdentitiesDeleteIdentityRequestBody as the provided V2IdentitiesDeleteIdentityRequestBody0
func (t *V2IdentitiesDeleteIdentityRequestBody) FromV2IdentitiesDeleteIdentityRequestBody0(v V2IdentitiesDeleteIdentityRequestBody0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2IdentitiesDeleteIdentityRequestBody0 performs a merge with any union data inside the V2IdentitiesDeleteIdentityRequestBody, using the provided V2IdentitiesDeleteIdentityRequestBody0
func (t *V2IdentitiesDeleteIdentityRequestBody) MergeV2IdentitiesDeleteIdentityRequestBody0(v V2IdentitiesDeleteIdentityRequestBody0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV2IdentitiesDeleteIdentityRequestBody1 returns the union data inside the V2IdentitiesDeleteIdentityRequestBody as a V2IdentitiesDeleteIdentityRequestBody1
func (t V2IdentitiesDeleteIdentityRequestBody) AsV2IdentitiesDeleteIdentityRequestBody1() (V2IdentitiesDeleteIdentityRequestBody1, error) {
	var body V2IdentitiesDeleteIdentityRequestBody1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2IdentitiesDeleteIdentityRequestBody1 overwrites any union data inside the V2IdentitiesDeleteIdentityRequestBody as the provided V2IdentitiesDeleteIdentityRequestBody1
func (t *V2IdentitiesDeleteIdentityRequestBody) FromV2IdentitiesDeleteIdentityRequestBody1(v V2IdentitiesDeleteIdentityRequestBody1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2IdentitiesDeleteIdentityRequestBody1 performs a merge with any union data inside the V2IdentitiesDeleteIdentityRequestBody, using the provided V2IdentitiesDeleteIdentityRequestBody1
func (t *V2IdentitiesDeleteIdentityRequestBody) MergeV2IdentitiesDeleteIdentityRequestBody1(v V2IdentitiesDeleteIdentityRequestBody1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V2IdentitiesDeleteIdentityRequestBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.ExternalId != nil {
		object["externalId"], err = json.Marshal(t.ExternalId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'externalId': %w", err)
		}
	}

	if t.IdentityId != nil {
		object["identityId"], err = json.Marshal(t.IdentityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'identityId': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *V2IdentitiesDeleteIdentityRequestBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["externalId"]; found {
		err = json.Unmarshal(raw, &t.ExternalId)
		if err != nil {
			return fmt.Errorf("error reading 'externalId': %w", err)
		}
	}

	if raw, found := object["identityId"]; found {
		err = json.Unmarshal(raw, &t.IdentityId)
		if err != nil {
			return fmt.Errorf("error reading 'identityId': %w", err)
		}
	}

	return err
}

// AsV2KeysVerifyKeyRequestBodyPermissions0 returns the union data inside the V2KeysVerifyKeyRequestBody_Permissions as a V2KeysVerifyKeyRequestBodyPermissions0
func (t V2KeysVerifyKeyRequestBody_Permissions) AsV2KeysVerifyKeyRequestBodyPermissions0() (V2KeysVerifyKeyRequestBodyPermissions0, error) {
	var body V2KeysVerifyKeyRequestBodyPermissions0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2KeysVerifyKeyRequestBodyPermissions0 overwrites any union data inside the V2KeysVerifyKeyRequestBody_Permissions as the provided V2KeysVerifyKeyRequestBodyPermissions0
func (t *V2KeysVerifyKeyRequestBody_Permissions) FromV2KeysVerifyKeyRequestBodyPermissions0(v V2KeysVerifyKeyRequestBodyPermissions0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2KeysVerifyKeyRequestBodyPermissions0 performs a merge with any union data inside the V2KeysVerifyKeyRequestBody_Permissions, using the provided V2KeysVerifyKeyRequestBodyPermissions0
func (t *V2KeysVerifyKeyRequestBody_Permissions) MergeV2KeysVerifyKeyRequestBodyPermissions0(v V2KeysVerifyKeyRequestBodyPermissions0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV2KeysVerifyKeyRequestBodyPermissions1 returns the union data inside the V2KeysVerifyKeyRequestBody_Permissions as a V2KeysVerifyKeyRequestBodyPermissions1
func (t V2KeysVerifyKeyRequestBody_Permissions) AsV2KeysVerifyKeyRequestBodyPermissions1() (V2KeysVerifyKeyRequestBodyPermissions1, error) {
	var body V2KeysVerifyKeyRequestBodyPermissions1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2KeysVerifyKeyRequestBodyPermissions1 overwrites any union data inside the V2KeysVerifyKeyRequestBody_Permissions as the provided V2KeysVerifyKeyRequestBodyPermissions1
func (t *V2KeysVerifyKeyRequestBody_Permissions) FromV2KeysVerifyKeyRequestBodyPermissions1(v V2KeysVerifyKeyRequestBodyPermissions1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2KeysVerifyKeyRequestBodyPermissions1 performs a merge with any union data inside the V2KeysVerifyKeyRequestBody_Permissions, using the provided V2KeysVerifyKeyRequestBodyPermissions1
func (t *V2KeysVerifyKeyRequestBody_Permissions) MergeV2KeysVerifyKeyRequestBodyPermissions1(v V2KeysVerifyKeyRequestBodyPermissions1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V2KeysVerifyKeyRequestBody_Permissions) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V2KeysVerifyKeyRequestBody_Permissions) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
