// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/oapi-codegen/nullable"
	"github.com/oapi-codegen/runtime"
)

const (
	RootKeyScopes = "rootKey.Scopes"
)

// Defines values for KeyCreditsRefillInterval.
const (
	KeyCreditsRefillIntervalDaily   KeyCreditsRefillInterval = "daily"
	KeyCreditsRefillIntervalMonthly KeyCreditsRefillInterval = "monthly"
)

// Defines values for KeysGetKeyResponseDataCreditsRefillInterval.
const (
	KeysGetKeyResponseDataCreditsRefillIntervalDaily   KeysGetKeyResponseDataCreditsRefillInterval = "daily"
	KeysGetKeyResponseDataCreditsRefillIntervalMonthly KeysGetKeyResponseDataCreditsRefillInterval = "monthly"
)

// Defines values for KeysVerifyKeyResponseDataCode.
const (
	DISABLED                KeysVerifyKeyResponseDataCode = "DISABLED"
	EXPIRED                 KeysVerifyKeyResponseDataCode = "EXPIRED"
	FORBIDDEN               KeysVerifyKeyResponseDataCode = "FORBIDDEN"
	INSUFFICIENTPERMISSIONS KeysVerifyKeyResponseDataCode = "INSUFFICIENT_PERMISSIONS"
	NOTFOUND                KeysVerifyKeyResponseDataCode = "NOT_FOUND"
	RATELIMITED             KeysVerifyKeyResponseDataCode = "RATE_LIMITED"
	UNAUTHORIZED            KeysVerifyKeyResponseDataCode = "UNAUTHORIZED"
	USAGEEXCEEDED           KeysVerifyKeyResponseDataCode = "USAGE_EXCEEDED"
	VALID                   KeysVerifyKeyResponseDataCode = "VALID"
)

// Defines values for V2KeysCreateKeyRequestBodyCreditsRefillInterval.
const (
	V2KeysCreateKeyRequestBodyCreditsRefillIntervalDaily   V2KeysCreateKeyRequestBodyCreditsRefillInterval = "daily"
	V2KeysCreateKeyRequestBodyCreditsRefillIntervalMonthly V2KeysCreateKeyRequestBodyCreditsRefillInterval = "monthly"
)

// Defines values for V2KeysUpdateKeyRequestBodyCreditsRefillInterval.
const (
	V2KeysUpdateKeyRequestBodyCreditsRefillIntervalDaily   V2KeysUpdateKeyRequestBodyCreditsRefillInterval = "daily"
	V2KeysUpdateKeyRequestBodyCreditsRefillIntervalMonthly V2KeysUpdateKeyRequestBodyCreditsRefillInterval = "monthly"
)

// Defines values for V2KeysVerifyKeyRequestBodyPermissions1Type.
const (
	And V2KeysVerifyKeyRequestBodyPermissions1Type = "and"
	Or  V2KeysVerifyKeyRequestBodyPermissions1Type = "or"
)

// ApisCreateApiResponseData defines model for ApisCreateApiResponseData.
type ApisCreateApiResponseData struct {
	// ApiId The id of the API
	ApiId string `json:"apiId"`
}

// ApisGetApiResponseData defines model for ApisGetApiResponseData.
type ApisGetApiResponseData struct {
	// Id The id of the API
	Id string `json:"id"`

	// Name The name of the API
	Name string `json:"name"`
}

// ApisListKeysResponseData defines model for ApisListKeysResponseData.
type ApisListKeysResponseData = []KeyResponse

// BadRequestErrorDetails defines model for BadRequestErrorDetails.
type BadRequestErrorDetails struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Errors Optional list of individual error details
	Errors []ValidationError `json:"errors"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code
	Status int `json:"status"`

	// Title A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
	Title string `json:"title"`

	// Type A URI reference to human-readable documentation for the error.
	Type string `json:"type"`
}

// BadRequestErrorResponse defines model for BadRequestErrorResponse.
type BadRequestErrorResponse struct {
	Error BadRequestErrorDetails `json:"error"`
	Meta  Meta                   `json:"meta"`
}

// BaseError defines model for BaseError.
type BaseError struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code
	Status int `json:"status"`

	// Title A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
	Title string `json:"title"`

	// Type A URI reference to human-readable documentation for the error.
	Type string `json:"type"`
}

// ConflictErrorResponse defines model for ConflictErrorResponse.
type ConflictErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// ForbiddenErrorResponse defines model for ForbiddenErrorResponse.
type ForbiddenErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// IdentitiesCreateIdentityResponseData defines model for IdentitiesCreateIdentityResponseData.
type IdentitiesCreateIdentityResponseData struct {
	// IdentityId The id of the identity. Used internally, you do not need to store this.
	IdentityId string `json:"identityId"`
}

// Identity defines model for Identity.
type Identity struct {
	// ExternalId External identity ID
	ExternalId string `json:"externalId"`

	// Id Identity ID
	Id string `json:"id"`

	// Meta Identity metadata
	Meta *map[string]interface{} `json:"meta,omitempty"`
}

// InternalServerErrorResponse defines model for InternalServerErrorResponse.
type InternalServerErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// KeyCredits Remaining requests for this key
type KeyCredits struct {
	Refill *KeyCreditsRefill `json:"refill,omitempty"`

	// Remaining Remaining credits
	Remaining int `json:"remaining"`
}

// KeyCreditsRefill defines model for KeyCreditsRefill.
type KeyCreditsRefill struct {
	// Amount Amount to refill
	Amount int `json:"amount"`

	// Interval Refill interval
	Interval KeyCreditsRefillInterval `json:"interval"`

	// LastRefillAt Last time the key was refilled (Unix timestamp)
	LastRefillAt *int64 `json:"lastRefillAt,omitempty"`

	// RefillDay Day of the month when refill happens (for monthly interval)
	RefillDay *int `json:"refillDay,omitempty"`
}

// KeyCreditsRefillInterval Refill interval
type KeyCreditsRefillInterval string

// KeyResponse defines model for KeyResponse.
type KeyResponse struct {
	// CreatedAt When the key was created (Unix timestamp)
	CreatedAt int64 `json:"createdAt"`

	// Credits Remaining requests for this key
	Credits *KeyCredits `json:"credits,omitempty"`

	// Environment Optional environment tag
	Environment *string `json:"environment,omitempty"`

	// Expires When the key expires (Unix timestamp)
	Expires  *int64    `json:"expires,omitempty"`
	Identity *Identity `json:"identity,omitempty"`

	// KeyId The key ID
	KeyId string `json:"keyId"`

	// Meta Optional metadata for the key
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name Optional name for the key
	Name *string `json:"name,omitempty"`

	// Permissions Permissions assigned to this key
	Permissions *[]string `json:"permissions,omitempty"`

	// Plaintext The decrypted key value (only included if decrypt=true)
	Plaintext *string `json:"plaintext,omitempty"`

	// Roles Roles assigned to this key
	Roles *[]string `json:"roles,omitempty"`

	// Start The first few characters of the key
	Start string `json:"start"`

	// UpdatedAt When the key was last updated (Unix timestamp)
	UpdatedAt *int64 `json:"updatedAt,omitempty"`
}

// KeysCreateKeyResponseData defines model for KeysCreateKeyResponseData.
type KeysCreateKeyResponseData struct {
	// Key The full generated API key that should be provided to your user. This is the only time you'll receive the complete key value - Unkey only stores a hashed version. Never store this value yourself; pass it securely to your end user.
	Key string `json:"key"`

	// KeyId The unique identifier for this key in Unkey's system. This is not secret and can be stored as a reference for later operations like updating or deleting the key.
	KeyId string `json:"keyId"`
}

// KeysDeleteKeyResponseData Empty response object. A successful response indicates the key was deleted successfully. Deletion triggers cache invalidation across all regions, but it may take up to 30 seconds for the deletion to be fully propagated due to eventual consistency. During this propagation period, some verification attempts might still succeed in certain regions.
type KeysDeleteKeyResponseData = map[string]interface{}

// KeysGetKeyResponseData defines model for KeysGetKeyResponseData.
type KeysGetKeyResponseData struct {
	// ApiId The ID of the API this key belongs to.
	ApiId *string `json:"apiId,omitempty"`

	// CreatedAt Unix timestamp (in milliseconds) when the key was created.
	CreatedAt int64 `json:"createdAt"`

	// Credits Usage limits configuration for this key. Credits provide a way to limit the number of times a key can be used before becoming invalid. Unlike ratelimits, credits are globally consistent (using database transactions) providing 100% accuracy at the cost of slightly higher latency. Ideal for monetization, usage quotas, or strict limits that must not be exceeded. See the 'refill' field for automatic replenishment options.
	Credits *struct {
		// Refill Configuration for automatic credit refills.
		Refill *struct {
			// Amount Number of credits added during each refill.
			Amount int `json:"amount"`

			// Interval How often the credits are automatically refilled.
			Interval KeysGetKeyResponseDataCreditsRefillInterval `json:"interval"`

			// LastRefillAt Unix timestamp (in milliseconds) when credits were last refilled.
			LastRefillAt *int64 `json:"lastRefillAt,omitempty"`

			// RefillDay For monthly refills, the day of month when refills occur.
			RefillDay *int `json:"refillDay,omitempty"`
		} `json:"refill,omitempty"`

		// Remaining The number of times this key can still be used before becoming invalid.
		Remaining *int32 `json:"remaining,omitempty"`
	} `json:"credits,omitempty"`

	// Enabled Whether the key is currently active. Disabled keys will fail verification with code=DISABLED. Toggling this allows you to temporarily suspend access without deleting the key, which is useful for maintenance, account freezing, or debugging. Can be updated using the updateKey endpoint.
	Enabled bool `json:"enabled"`

	// Expires Unix timestamp (in milliseconds) when this key will automatically expire. If null, the key has no expiration.
	Expires *int64 `json:"expires,omitempty"`

	// ExternalId Your user's unique identifier, creating a link between Unkey and your system. This ID is returned during verification so you can identify which customer/entity is making the request without performing additional database lookups. Use consistent identifiers that match your primary user/tenant identifiers for seamless integration.
	ExternalId *string `json:"externalId,omitempty"`

	// Id The unique identifier of the key in Unkey's system.
	Id string `json:"id"`

	// Identity The identity associated with this key, if any. Identities allow resource sharing (like ratelimits) across multiple keys belonging to the same user/entity. This enables scenarios like issuing separate keys for different devices/services while maintaining global usage limits for the user. An identity's externalId typically matches your user ID or tenant ID.
	Identity *struct {
		// ExternalId Your identifier for this identity in your system.
		ExternalId string `json:"externalId"`

		// Id The unique ID of the identity in Unkey's system.
		Id string `json:"id"`

		// Meta Additional metadata associated with this identity.
		Meta *map[string]interface{} `json:"meta,omitempty"`
	} `json:"identity,omitempty"`

	// Meta Arbitrary JSON metadata associated with this key. This can include additional context like subscription plans, feature flags, or any custom data. Metadata is stored as-is and returned during verification, allowing you to access important information without additional database queries. Consider including data relevant to authorization decisions, usage tracking, and user context.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name A descriptive name for the key for internal reference. Shown in dashboards and logs but never exposed to end users.
	Name *string `json:"name,omitempty"`

	// Permissions List of permission names directly assigned to this key.
	Permissions *[]string `json:"permissions,omitempty"`

	// Plaintext The full API key in plaintext. Only included when 'decrypt' is true and the key was created with 'recoverable: true'. SECURITY RISK: This field contains the actual secret key which should never be logged, stored in databases, or exposed in any frontend code. It should only be displayed directly to users through secure channels. Most applications should avoid setting decrypt=true unless absolutely necessary.
	Plaintext *string `json:"plaintext,omitempty"`

	// Ratelimits Array of ratelimits applied to this key. Multiple named ratelimits can control different aspects of key usage. For example, a 'requests' ratelimit might control overall API calls while a separate 'computations' limit manages access to resource-intensive operations. Ratelimits are optimized for performance and typically add minimal latency to verifications. They can be shared across keys through identities.
	Ratelimits *[]struct {
		// Async Whether this ratelimit uses fast (async=true) or consistent (async=false) mode. Fast mode has lower latency but less accuracy.
		Async *bool `json:"async,omitempty"`

		// Duration Duration of the ratelimit window in milliseconds.
		Duration int32 `json:"duration"`

		// Limit Maximum number of operations allowed within the time window.
		Limit int32 `json:"limit"`

		// Name Identifier for this ratelimit.
		Name string `json:"name"`
	} `json:"ratelimits,omitempty"`

	// Roles List of role names assigned to this key. Roles are collections of permissions.
	Roles *[]string `json:"roles,omitempty"`

	// Start The first few characters of the key to visually identify it without exposing the full key. Used in dashboards and logs to help users recognize which key is being used without revealing sensitive information. Typically includes the prefix if one was specified.
	Start string `json:"start"`

	// UpdatedAt Unix timestamp (in milliseconds) when the key was last updated.
	UpdatedAt *int64 `json:"updatedAt,omitempty"`

	// WorkspaceId The ID of the workspace that owns this key.
	WorkspaceId string `json:"workspaceId"`
}

// KeysGetKeyResponseDataCreditsRefillInterval How often the credits are automatically refilled.
type KeysGetKeyResponseDataCreditsRefillInterval string

// KeysUpdateKeyResponseData Empty response object. A successful response indicates the key was updated successfully. Changes may take up to 30 seconds to propagate to all regions due to cache invalidation delays.
type KeysUpdateKeyResponseData = map[string]interface{}

// KeysVerifyKeyResponseData defines model for KeysVerifyKeyResponseData.
type KeysVerifyKeyResponseData struct {
	// Code A machine readable code why the key is not valid. Possible values are: VALID, NOT_FOUND, FORBIDDEN, USAGE_EXCEEDED, RATE_LIMITED, UNAUTHORIZED, DISABLED, INSUFFICIENT_PERMISSIONS, EXPIRED
	Code KeysVerifyKeyResponseDataCode `json:"code"`

	// Credits The number of requests that can be made with this key before it becomes invalid. If null or undefined, the key has no request limit.
	Credits *int32 `json:"credits,omitempty"`

	// Enabled Sets the key to be enabled or disabled. Disabled keys will not verify.
	Enabled *bool `json:"enabled,omitempty"`

	// Environment The environment of the key, this is what was set when you created the key
	Environment *string `json:"environment,omitempty"`

	// Expires The unix timestamp in milliseconds when the key will expire. If null or undefined, the key is not expiring.
	Expires *int64 `json:"expires,omitempty"`

	// ExternalId The id of the tenant associated with this key.
	ExternalId *string   `json:"externalId,omitempty"`
	Identity   *Identity `json:"identity,omitempty"`

	// KeyId The id of the key
	KeyId *string `json:"keyId,omitempty"`

	// Meta Any additional metadata stored with the key
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name The name of the key, give keys a name to easily identify their purpose
	Name *string `json:"name,omitempty"`

	// Permissions A list of all the permissions this key is connected to.
	Permissions *[]string `json:"permissions,omitempty"`

	// Ratelimits Ratelimit information for the key
	Ratelimits *[]struct {
		// Limit Maximum number of requests that can be made inside a window
		Limit int32 `json:"limit"`

		// Name The name of the ratelimit
		Name string `json:"name"`

		// Remaining Remaining requests after this verification
		Remaining int32 `json:"remaining"`

		// Reset Unix timestamp in milliseconds when the ratelimit will reset
		Reset int64 `json:"reset"`
	} `json:"ratelimits,omitempty"`

	// Roles A list of all the roles this key is connected to.
	Roles *[]string `json:"roles,omitempty"`

	// Valid Whether the key is valid or not.
	Valid bool `json:"valid"`
}

// KeysVerifyKeyResponseDataCode A machine readable code why the key is not valid. Possible values are: VALID, NOT_FOUND, FORBIDDEN, USAGE_EXCEEDED, RATE_LIMITED, UNAUTHORIZED, DISABLED, INSUFFICIENT_PERMISSIONS, EXPIRED
type KeysVerifyKeyResponseDataCode string

// LivenessResponseData defines model for LivenessResponseData.
type LivenessResponseData struct {
	// Message Whether we're alive or not
	Message string `json:"message"`
}

// Meta defines model for Meta.
type Meta struct {
	// RequestId A unique id for this request. Please always provide this to support.
	RequestId string `json:"requestId"`
}

// NotFoundErrorResponse defines model for NotFoundErrorResponse.
type NotFoundErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	// Cursor Opaque token for retrieving the next set of results
	Cursor *string `json:"cursor,omitempty"`

	// HasMore Indicates if more results exist beyond this page
	HasMore *bool `json:"hasMore,omitempty"`
}

// Permission defines model for Permission.
type Permission struct {
	// CreatedAt When the permission was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description A description of what this permission grants access to
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the permission
	Id string `json:"id"`

	// Name The unique name of the permission
	Name string `json:"name"`

	// WorkspaceId The workspace this permission belongs to
	WorkspaceId string `json:"workspaceId"`
}

// PermissionsCreatePermissionResponseData defines model for PermissionsCreatePermissionResponseData.
type PermissionsCreatePermissionResponseData struct {
	// PermissionId The id of the permission. This is used internally
	PermissionId string `json:"permissionId"`
}

// PermissionsGetPermissionResponseData defines model for PermissionsGetPermissionResponseData.
type PermissionsGetPermissionResponseData struct {
	Permission Permission `json:"permission"`
}

// PermissionsListPermissionsResponseData defines model for PermissionsListPermissionsResponseData.
type PermissionsListPermissionsResponseData struct {
	// Cursor Cursor for pagination
	Cursor      *string      `json:"cursor,omitempty"`
	Permissions []Permission `json:"permissions"`

	// Total Total number of permissions
	Total int `json:"total"`
}

// PermissionsListRolesResponseData defines model for PermissionsListRolesResponseData.
type PermissionsListRolesResponseData struct {
	// Cursor Cursor for pagination
	Cursor *string               `json:"cursor,omitempty"`
	Roles  []RoleWithPermissions `json:"roles"`

	// Total Total number of roles
	Total int `json:"total"`
}

// PreconditionFailedErrorResponse defines model for PreconditionFailedErrorResponse.
type PreconditionFailedErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// Ratelimit defines model for Ratelimit.
type Ratelimit struct {
	// Duration The duration for each ratelimit window in milliseconds.
	Duration int64 `json:"duration"`

	// Limit How many requests may pass within a given window before requests are rejected.
	Limit int64 `json:"limit"`

	// Name The name of this limit. You will need to use this again when verifying a key.
	Name string `json:"name"`
}

// RatelimitDeleteOverrideResponseData defines model for RatelimitDeleteOverrideResponseData.
type RatelimitDeleteOverrideResponseData = map[string]interface{}

// RatelimitLimitResponseData defines model for RatelimitLimitResponseData.
type RatelimitLimitResponseData struct {
	// Limit The maximum number of requests allowed.
	Limit int64 `json:"limit"`

	// OverrideId The override that was used. May be empty
	OverrideId *string `json:"overrideId,omitempty"`

	// Remaining The number of requests remaining in the current window.
	Remaining int64 `json:"remaining"`

	// Reset The time in milliseconds when the rate limit will reset.
	Reset int64 `json:"reset"`

	// Success Whether the request passed the ratelimit. If false, the request must be blocked.
	Success bool `json:"success"`
}

// RatelimitListOverridesResponseData defines model for RatelimitListOverridesResponseData.
type RatelimitListOverridesResponseData = []RatelimitOverride

// RatelimitOverride defines model for RatelimitOverride.
type RatelimitOverride struct {
	// Duration The duration in milliseconds for the rate limit window.
	Duration int64 `json:"duration"`

	// Identifier Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( * ) can be used to match multiple identifiers, More info can be found at https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules
	Identifier string `json:"identifier"`

	// Limit The maximum number of requests allowed.
	Limit int64 `json:"limit"`

	// NamespaceId The id of the namespace.
	NamespaceId string `json:"namespaceId"`

	// OverrideId The id of the override.
	OverrideId string `json:"overrideId"`
}

// RatelimitSetOverrideResponseData defines model for RatelimitSetOverrideResponseData.
type RatelimitSetOverrideResponseData struct {
	// OverrideId The id of the override. This is used internally.
	OverrideId string `json:"overrideId"`
}

// RoleWithPermissions defines model for RoleWithPermissions.
type RoleWithPermissions struct {
	// CreatedAt When the role was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description A description of what this role represents
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the role
	Id string `json:"id"`

	// Name The unique name of the role
	Name string `json:"name"`

	// Permissions The permissions assigned to this role
	Permissions []Permission `json:"permissions"`

	// WorkspaceId The workspace this role belongs to
	WorkspaceId string `json:"workspaceId"`
}

// UnauthorizedErrorResponse defines model for UnauthorizedErrorResponse.
type UnauthorizedErrorResponse struct {
	Error BaseError `json:"error"`
	Meta  Meta      `json:"meta"`
}

// V2ApisCreateApiRequestBody defines model for V2ApisCreateApiRequestBody.
type V2ApisCreateApiRequestBody struct {
	// Name The name for your API. This is not customer facing.
	Name string `json:"name"`
}

// V2ApisCreateApiResponseBody defines model for V2ApisCreateApiResponseBody.
type V2ApisCreateApiResponseBody struct {
	Data ApisCreateApiResponseData `json:"data"`
	Meta Meta                      `json:"meta"`
}

// V2ApisDeleteApiRequestBody defines model for V2ApisDeleteApiRequestBody.
type V2ApisDeleteApiRequestBody struct {
	// ApiId The id of the API you want to delete. API ids always start with `api_`
	ApiId string `json:"apiId"`
}

// V2ApisDeleteApiResponseBody defines model for V2ApisDeleteApiResponseBody.
type V2ApisDeleteApiResponseBody struct {
	Meta Meta `json:"meta"`
}

// V2ApisGetApiRequestBody defines model for V2ApisGetApiRequestBody.
type V2ApisGetApiRequestBody struct {
	// ApiId The id of the api to fetch
	ApiId string `json:"apiId"`
}

// V2ApisGetApiResponseBody defines model for V2ApisGetApiResponseBody.
type V2ApisGetApiResponseBody struct {
	Data ApisGetApiResponseData `json:"data"`
	Meta Meta                   `json:"meta"`
}

// V2ApisListKeysRequestBody defines model for V2ApisListKeysRequestBody.
type V2ApisListKeysRequestBody struct {
	// ApiId The id of the api to fetch
	ApiId string `json:"apiId"`

	// Cursor Use this to fetch the next page of results. A new cursor will be returned in the response if there are more results.
	Cursor *string `json:"cursor,omitempty"`

	// Decrypt Decrypt and display the raw key. Only possible if the key was encrypted when generated.
	Decrypt *bool `json:"decrypt,omitempty"`

	// ExternalId If provided, this will only return keys where the `externalId` matches.
	ExternalId *string `json:"externalId,omitempty"`

	// Limit The maximum number of keys to return
	Limit *int `json:"limit,omitempty"`

	// RevalidateKeysCache EXPERIMENTAL: Skip the cache and fetch the keys from the database directly. When you're creating a key and immediately listing all keys to display them to your user, you might want to skip the cache to ensure the key is displayed immediately.
	RevalidateKeysCache *bool `json:"revalidateKeysCache,omitempty"`
}

// V2ApisListKeysResponseBody defines model for V2ApisListKeysResponseBody.
type V2ApisListKeysResponseBody struct {
	Data       ApisListKeysResponseData `json:"data"`
	Meta       Meta                     `json:"meta"`
	Pagination *Pagination              `json:"pagination,omitempty"`
}

// V2IdentitiesCreateIdentityRequestBody defines model for V2IdentitiesCreateIdentityRequestBody.
type V2IdentitiesCreateIdentityRequestBody struct {
	// ExternalId The id of this identity in your system.
	//
	// This usually comes from your authentication provider and could be a userId, organisationId or even an email.
	// It does not matter what you use, as long as it uniquely identifies something in your application.
	//
	// `externalId`s are unique across your workspace and therefore a `CONFLICT` error is returned when you try to create duplicates.
	ExternalId string `json:"externalId"`

	// Meta Attach metadata to this identity that you need to have access to when verifying a key.
	//
	// This will be returned as part of the `verifyKey` response.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Ratelimits Attach ratelimits to this identity.
	//
	// When verifying keys, you can specify which limits you want to use and all keys attached to this identity, will share the limits.
	Ratelimits *[]Ratelimit `json:"ratelimits,omitempty"`
}

// V2IdentitiesCreateIdentityResponseBody defines model for V2IdentitiesCreateIdentityResponseBody.
type V2IdentitiesCreateIdentityResponseBody struct {
	Data IdentitiesCreateIdentityResponseData `json:"data"`
	Meta Meta                                 `json:"meta"`
}

// V2IdentitiesDeleteIdentityRequestBody defines model for V2IdentitiesDeleteIdentityRequestBody.
type V2IdentitiesDeleteIdentityRequestBody struct {
	// ExternalId The id of this identity in your system.
	//
	// This usually comes from your authentication provider and could be a userId, organisationId or even an email.
	// It does not matter what you use, as long as it uniquely identifies something in your application.
	ExternalId *string `json:"externalId,omitempty"`

	// IdentityId The Unkey Identity ID.
	IdentityId *string `json:"identityId,omitempty"`
	union      json.RawMessage
}

// V2IdentitiesDeleteIdentityRequestBody0 defines model for .
type V2IdentitiesDeleteIdentityRequestBody0 = interface{}

// V2IdentitiesDeleteIdentityRequestBody1 defines model for .
type V2IdentitiesDeleteIdentityRequestBody1 = interface{}

// V2IdentitiesDeleteIdentityResponseBody defines model for V2IdentitiesDeleteIdentityResponseBody.
type V2IdentitiesDeleteIdentityResponseBody = map[string]interface{}

// V2KeysAddPermissionsRequestBody defines model for V2KeysAddPermissionsRequestBody.
type V2KeysAddPermissionsRequestBody struct {
	// KeyId The ID of the key to which permissions will be added (begins with 'key_')
	KeyId string `json:"keyId"`

	// Permissions List of permissions to add to the key. Each permission can be identified by ID or name (if both are provided in the same object, ID takes precedence). Duplicate permissions are automatically handled (adding the same permission twice has no effect). Permissions follow a hierarchical naming structure (e.g., 'documents.read', 'documents.write') and are checked during key verification to control access to protected resources. Note that in addition to direct permissions added here, keys may also have permissions granted through roles (use /v2/keys.addRoles for role management).
	Permissions []struct {
		// Create When true, if a permission with this name doesn't exist, it will be automatically created. Only works when specifying name, not ID. Requires the rbac.*.create_permission permission on your root key. SECURITY CONSIDERATION: Use this flag carefully as it creates permission entities in your workspace and could lead to permission proliferation if not properly managed.
		Create *bool `json:"create,omitempty"`

		// Id The ID of an existing permission (begins with 'perm_'). Provide either ID or name. Use ID when you know the exact permission identifier and want to ensure you're referencing a specific permission.
		Id *string `json:"id,omitempty"`

		// Name The name of the permission. Provide either ID or name. Permission names typically follow a 'resource.action' format (e.g., 'documents.read', 'users.delete'). Use consistent naming patterns to create logical permission hierarchies.
		Name *string `json:"name,omitempty"`
	} `json:"permissions"`
}

// V2KeysAddPermissionsResponse defines model for V2KeysAddPermissionsResponse.
type V2KeysAddPermissionsResponse struct {
	// Data Complete list of all permissions directly assigned to the key (including both newly added permissions and those that were already assigned). Note that this list does not include permissions granted through roles - see /v2/keys.getKey for complete permission information. Use this comprehensive list to track the key's current direct permission state. The list is always sorted alphabetically by permission name for consistency. An empty array indicates the key has no direct permissions assigned.
	Data V2KeysAddPermissionsResponseData `json:"data"`
	Meta Meta                             `json:"meta"`
}

// V2KeysAddPermissionsResponseData Complete list of all permissions directly assigned to the key (including both newly added permissions and those that were already assigned). Note that this list does not include permissions granted through roles - see /v2/keys.getKey for complete permission information. Use this comprehensive list to track the key's current direct permission state. The list is always sorted alphabetically by permission name for consistency. An empty array indicates the key has no direct permissions assigned.
type V2KeysAddPermissionsResponseData = []struct {
	// Id The unique identifier of the permission (begins with 'perm_'). This ID can be used in other API calls to reference this specific permission.
	Id string `json:"id"`

	// Name The name of the permission, typically following a 'resource.action' pattern like 'documents.read'. This name is checked during verification to determine if a key has access to a specific action. For wildcard permissions, you can use patterns like 'documents.*' (grants all document permissions) during verification, but each specific permission must be added individually here.
	Name string `json:"name"`
}

// V2KeysCreateKeyRequestBody defines model for V2KeysCreateKeyRequestBody.
type V2KeysCreateKeyRequestBody struct {
	// ApiId The ID of the API where this key should be created. Each key is associated with exactly one API, which helps segregate keys between different environments (dev/prod) and services.
	ApiId string `json:"apiId"`

	// ByteLength Controls the cryptographic strength and length of the generated key. Higher values provide more security but result in longer keys. The default (16 bytes) provides 2^128 possible combinations, sufficient for most uses.
	ByteLength *int `json:"byteLength,omitempty"`

	// Credits Usage limits configuration for this key. Credits provide a way to limit the number of times a key can be used. Unlike ratelimits, these are guaranteed to be globally consistent (using database transactions) but add latency to verifications.
	Credits *struct {
		// Refill Configuration for automatic credit refills.
		Refill *struct {
			// Amount Number of credits to add during each refill.
			Amount int `json:"amount"`

			// Interval How often the credits should be refilled.
			Interval V2KeysCreateKeyRequestBodyCreditsRefillInterval `json:"interval"`

			// RefillDay For monthly refills, the day of month when refills occur.
			RefillDay *int `json:"refillDay,omitempty"`
		} `json:"refill,omitempty"`

		// Remaining Number of times this key can be used before becoming invalid. Set to null for unlimited uses.
		Remaining int32 `json:"remaining"`
	} `json:"credits,omitempty"`

	// Enabled Controls whether the key is active upon creation. Disabled keys will fail verification with code DISABLED. This is useful for preparing keys that will be activated later or temporarily disabling access without deleting the key.
	Enabled *bool `json:"enabled,omitempty"`

	// Expires Unix timestamp (in milliseconds) when this key will automatically expire. Use temporary keys for time-limited access, one-time operations, or emergency access. After expiration, the key will fail verification with code EXPIRED.
	Expires *int64 `json:"expires,omitempty"`

	// ExternalId Your user's unique identifier, creating a link between Unkey and your system. This ID is returned during verification so you can identify which customer/entity is making the request. Use consistent IDs from your user management system.
	ExternalId *string `json:"externalId,omitempty"`

	// Meta Arbitrary JSON metadata to associate with this key. This is useful for storing additional context like subscription plans, feature flags, or any custom data you'd like to access during verification without additional database lookups.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name A human-readable name for the key for your internal reference. This is shown in dashboards and logs but never exposed to end users.
	Name *string `json:"name,omitempty"`

	// Permissions Individual permissions to assign directly to this key. These are checked during verification alongside any permissions granted via roles. Use structured naming like 'resource.action' for clarity.
	Permissions *[]string `json:"permissions,omitempty"`

	// Prefix Optional prefix for the key that helps identify its purpose. The underscore is automatically added (e.g., 'prod' becomes 'prod_xxxxxxxxx'). Use prefixes like 'prod', 'dev', or service names to help users understand the key's purpose at a glance.
	Prefix *string `json:"prefix,omitempty"`

	// Ratelimits Array of ratelimits to apply to this key. Ratelimits provide protection against abuse by limiting how frequently a key can be used. Multiple named ratelimits can be used for different resources or operations (e.g., 'requests' for overall usage, 'computations' for expensive operations).
	Ratelimits *[]struct {
		// Duration Duration of the ratelimit window in milliseconds.
		Duration int32 `json:"duration"`

		// Limit Maximum number of operations allowed within the time window.
		Limit int32 `json:"limit"`

		// Name Identifier for this ratelimit. Use descriptive names like 'requests' or 'computations'.
		Name string `json:"name"`
	} `json:"ratelimits,omitempty"`

	// Recoverable If true, the plaintext key is stored in an encrypted vault, allowing it to be retrieved later. Use with caution as this reduces security by keeping a recoverable copy of the key. Best used for development keys or when absolutely necessary.
	Recoverable *bool `json:"recoverable,omitempty"`

	// Roles Roles to assign to this key for permission management. Each role represents a collection of permissions and must already exist in your workspace. During verification, all permissions from these roles will be checked against requested permissions.
	Roles *[]string `json:"roles,omitempty"`
}

// V2KeysCreateKeyRequestBodyCreditsRefillInterval How often the credits should be refilled.
type V2KeysCreateKeyRequestBodyCreditsRefillInterval string

// V2KeysCreateKeyResponseBody defines model for V2KeysCreateKeyResponseBody.
type V2KeysCreateKeyResponseBody struct {
	Data KeysCreateKeyResponseData `json:"data"`
	Meta Meta                      `json:"meta"`
}

// V2KeysDeleteKeyRequestBody defines model for V2KeysDeleteKeyRequestBody.
type V2KeysDeleteKeyRequestBody struct {
	// KeyId The unique identifier of the key to delete (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. Once deleted, verification attempts with this key will fail with code=NOT_FOUND and it will no longer appear in key listings.
	KeyId string `json:"keyId"`

	// Permanent Controls whether the key should be soft-deleted (default) or permanently erased from the database. Soft deletion marks the key as deleted but preserves its data, allowing potential recovery via direct database operations. Permanent deletion completely removes all traces of the key including its hash and metadata. Use permanent=true for regulatory compliance scenarios (like GDPR), resolving hash collisions during migrations, or when you need to reuse the same key string in the future. CAUTION: Permanent deletion cannot be undone.
	Permanent *bool `json:"permanent,omitempty"`
}

// V2KeysDeleteKeyResponseBody defines model for V2KeysDeleteKeyResponseBody.
type V2KeysDeleteKeyResponseBody struct {
	// Data Empty response object. A successful response indicates the key was deleted successfully. Deletion triggers cache invalidation across all regions, but it may take up to 30 seconds for the deletion to be fully propagated due to eventual consistency. During this propagation period, some verification attempts might still succeed in certain regions.
	Data *KeysDeleteKeyResponseData `json:"data,omitempty"`
	Meta Meta                       `json:"meta"`
}

// V2KeysGetKeyRequestBody defines model for V2KeysGetKeyRequestBody.
type V2KeysGetKeyRequestBody struct {
	// Decrypt Whether to include the plaintext key in the response. This is only possible for keys created with 'recoverable: true' and requires the 'decrypt_key' permission. SECURITY WARNING: This should be used sparingly and only for legitimate recovery purposes. Keys returned this way must be handled securely and not logged or stored insecurely. Most applications should set this to false.
	Decrypt *bool `json:"decrypt,omitempty"`

	// KeyId The unique identifier of the key to retrieve (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. You can find this ID in the creation response, key listings, or in the dashboard.
	KeyId string `json:"keyId"`
}

// V2KeysGetKeyResponseBody defines model for V2KeysGetKeyResponseBody.
type V2KeysGetKeyResponseBody struct {
	Data KeysGetKeyResponseData `json:"data"`
	Meta Meta                   `json:"meta"`
}

// V2KeysRemovePermissionsRequestBody defines model for V2KeysRemovePermissionsRequestBody.
type V2KeysRemovePermissionsRequestBody struct {
	// KeyId The unique identifier of the key from which permissions will be removed (begins with 'key_')
	KeyId string `json:"keyId"`

	// Permissions List of permissions to remove from the key. Each permission can be identified by ID or name (if both are provided in the same object, ID takes precedence). This operation only affects direct permissions on the key, not permissions granted through roles. Removing permissions that aren't assigned to the key is a no-op and doesn't cause an error.
	Permissions []struct {
		// Id The ID of the permission to remove (begins with 'perm_'). Provide either ID or name. Using ID is more precise and less prone to naming conflicts.
		Id *string `json:"id,omitempty"`

		// Name The name of the permission to remove. Provide either ID or name. Names should match exactly with the permission name as it was defined.
		Name *string `json:"name,omitempty"`
	} `json:"permissions"`
}

// V2KeysRemovePermissionsResponse defines model for V2KeysRemovePermissionsResponse.
type V2KeysRemovePermissionsResponse struct {
	// Data Empty response object. A successful response indicates the permissions were successfully removed. After removal, any cached versions of the key are invalidated to ensure consistency.
	Data V2KeysRemovePermissionsResponseData `json:"data"`
	Meta Meta                                `json:"meta"`
}

// V2KeysRemovePermissionsResponseData Empty response object. A successful response indicates the permissions were successfully removed. After removal, any cached versions of the key are invalidated to ensure consistency.
type V2KeysRemovePermissionsResponseData = map[string]interface{}

// V2KeysUpdateKeyRequestBody defines model for V2KeysUpdateKeyRequestBody.
type V2KeysUpdateKeyRequestBody struct {
	// Credits Usage limits configuration for this key. Set to null to disable usage limits. Omit this field to leave it unchanged. Note: Cannot set refill when credits is null; setting refillDay requires interval to be 'monthly'.
	Credits nullable.Nullable[struct {
		// Refill Configuration for automatic credit refills. Set to null to disable refills. Omit this field to leave it unchanged.
		Refill nullable.Nullable[struct {
			// Amount Number of credits to add during each refill.
			Amount int `json:"amount"`

			// Interval How often the credits should be refilled. For 'monthly' refills, you can specify the day of month using 'refillDay'.
			Interval V2KeysUpdateKeyRequestBodyCreditsRefillInterval `json:"interval"`

			// RefillDay For monthly refills, the day of month when refills occur. Cannot be used with 'daily' interval.
			RefillDay *int `json:"refillDay,omitempty"`
		}] `json:"refill,omitempty"`

		// Remaining Number of times this key can be used before becoming invalid. Required when specifying credits.
		Remaining int32 `json:"remaining"`
	}] `json:"credits,omitempty"`

	// Enabled Whether the key is currently active. Disabled keys will fail verification with code=DISABLED. Omit this field to leave it unchanged.
	Enabled *bool `json:"enabled,omitempty"`

	// Expires Unix timestamp (in milliseconds) when this key will automatically expire. Set to null to remove expiration. Omit this field to leave it unchanged.
	Expires nullable.Nullable[int64] `json:"expires,omitempty"`

	// ExternalId Your user's unique identifier, creating a link between Unkey and your system. Set to null to disconnect this key from any identity. Omit this field to leave it unchanged.
	ExternalId nullable.Nullable[string] `json:"externalId,omitempty"`

	// KeyId The unique identifier of the key to update (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself.
	KeyId string `json:"keyId"`

	// Meta Arbitrary JSON metadata to associate with this key. Set to null to remove all metadata. Omit this field to leave it unchanged.
	Meta nullable.Nullable[map[string]interface{}] `json:"meta,omitempty"`

	// Name A descriptive name for the key for internal reference. Set to null to remove the name. Omit this field to leave it unchanged.
	Name nullable.Nullable[string] `json:"name,omitempty"`

	// Ratelimits Array of ratelimits to apply to this key. Set to null to disable all ratelimits. Omit this field to leave it unchanged. Replaces the deprecated 'ratelimit' field from v1.
	Ratelimits nullable.Nullable[[]struct {
		// Async Whether this ratelimit uses fast (async=true) or consistent (async=false) mode. Fast mode has lower latency but less accuracy.
		Async *bool `json:"async,omitempty"`

		// Duration Duration of the ratelimit window in milliseconds.
		Duration int32 `json:"duration"`

		// Limit Maximum number of operations allowed within the time window.
		Limit int32 `json:"limit"`

		// Name Identifier for this ratelimit. Use descriptive names like 'requests' or 'computations'.
		Name string `json:"name"`
	}] `json:"ratelimits,omitempty"`
}

// V2KeysUpdateKeyRequestBodyCreditsRefillInterval How often the credits should be refilled. For 'monthly' refills, you can specify the day of month using 'refillDay'.
type V2KeysUpdateKeyRequestBodyCreditsRefillInterval string

// V2KeysUpdateKeyResponseBody defines model for V2KeysUpdateKeyResponseBody.
type V2KeysUpdateKeyResponseBody struct {
	// Data Empty response object. A successful response indicates the key was updated successfully. Changes may take up to 30 seconds to propagate to all regions due to cache invalidation delays.
	Data *KeysUpdateKeyResponseData `json:"data,omitempty"`
	Meta Meta                       `json:"meta"`
}

// V2KeysVerifyKeyRequestBody defines model for V2KeysVerifyKeyRequestBody.
type V2KeysVerifyKeyRequestBody struct {
	// ApiId The ID of the API where the key belongs to. Required to ensure keys from development environments aren't leaking into production and vice versa.
	ApiId string `json:"apiId"`

	// Credits Customize the behavior of deducting remaining uses. When some of your endpoints are more expensive than others, you can set a custom cost for each.
	Credits *struct {
		// Cost How many tokens should be deducted from the current credits. Set it to 0 to make it free.
		Cost *int32 `json:"cost,omitempty"`
	} `json:"credits,omitempty"`

	// Key The key to verify. Never store API keys yourself.
	Key string `json:"key"`

	// Permissions Perform RBAC permission checks
	Permissions *V2KeysVerifyKeyRequestBody_Permissions `json:"permissions,omitempty"`

	// Ratelimits You can check against multiple ratelimits when verifying a key.
	Ratelimits *[]struct {
		// Cost Optionally override how expensive this operation is and how many tokens are deducted from the current limit.
		Cost *int32 `json:"cost,omitempty"`

		// Duration Optionally override the ratelimit window duration.
		Duration *int32 `json:"duration,omitempty"`

		// Limit Optionally override the limit.
		Limit *int32 `json:"limit,omitempty"`

		// Name The name of the ratelimit.
		Name string `json:"name"`
	} `json:"ratelimits,omitempty"`

	// Tags Tags do not influence the outcome of a verification. They can be added to filter or aggregate historical verification data for your analytics needs.
	Tags *[]string `json:"tags,omitempty"`
}

// V2KeysVerifyKeyRequestBodyPermissions0 A single permission to check
type V2KeysVerifyKeyRequestBodyPermissions0 = string

// V2KeysVerifyKeyRequestBodyPermissions1 defines model for .
type V2KeysVerifyKeyRequestBodyPermissions1 struct {
	// Permissions List of permissions to check
	Permissions []string `json:"permissions"`

	// Type Logical operator to apply to the permissions
	Type V2KeysVerifyKeyRequestBodyPermissions1Type `json:"type"`
}

// V2KeysVerifyKeyRequestBodyPermissions1Type Logical operator to apply to the permissions
type V2KeysVerifyKeyRequestBodyPermissions1Type string

// V2KeysVerifyKeyRequestBody_Permissions Perform RBAC permission checks
type V2KeysVerifyKeyRequestBody_Permissions struct {
	union json.RawMessage
}

// V2KeysVerifyKeyResponseBody defines model for V2KeysVerifyKeyResponseBody.
type V2KeysVerifyKeyResponseBody struct {
	Data KeysVerifyKeyResponseData `json:"data"`
	Meta Meta                      `json:"meta"`
}

// V2LivenessResponseBody defines model for V2LivenessResponseBody.
type V2LivenessResponseBody struct {
	Data LivenessResponseData `json:"data"`
	Meta Meta                 `json:"meta"`
}

// V2PermissionsCreatePermissionRequestBody defines model for V2PermissionsCreatePermissionRequestBody.
type V2PermissionsCreatePermissionRequestBody struct {
	// Description Explain what this permission does. This is just for your team, your users will not see this.
	Description *string `json:"description,omitempty"`

	// Name The unique name of your permission
	Name string `json:"name"`
}

// V2PermissionsCreatePermissionResponseBody defines model for V2PermissionsCreatePermissionResponseBody.
type V2PermissionsCreatePermissionResponseBody struct {
	Data PermissionsCreatePermissionResponseData `json:"data"`
	Meta Meta                                    `json:"meta"`
}

// V2PermissionsDeleteRoleRequestBody defines model for V2PermissionsDeleteRoleRequestBody.
type V2PermissionsDeleteRoleRequestBody struct {
	// RoleId The id of the role to delete
	RoleId string `json:"roleId"`
}

// V2PermissionsDeleteRoleResponseBody defines model for V2PermissionsDeleteRoleResponseBody.
type V2PermissionsDeleteRoleResponseBody struct {
	Meta Meta `json:"meta"`
}

// V2PermissionsGetPermissionRequestBody defines model for V2PermissionsGetPermissionRequestBody.
type V2PermissionsGetPermissionRequestBody struct {
	// PermissionId The id of the permission to retrieve
	PermissionId string `json:"permissionId"`
}

// V2PermissionsGetPermissionResponseBody defines model for V2PermissionsGetPermissionResponseBody.
type V2PermissionsGetPermissionResponseBody struct {
	Data PermissionsGetPermissionResponseData `json:"data"`
	Meta Meta                                 `json:"meta"`
}

// V2PermissionsListPermissionsRequestBody defines model for V2PermissionsListPermissionsRequestBody.
type V2PermissionsListPermissionsRequestBody struct {
	// Cursor Cursor for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of permissions to return
	Limit *int32 `json:"limit,omitempty"`
}

// V2PermissionsListPermissionsResponseBody defines model for V2PermissionsListPermissionsResponseBody.
type V2PermissionsListPermissionsResponseBody struct {
	Data PermissionsListPermissionsResponseData `json:"data"`
	Meta Meta                                   `json:"meta"`
}

// V2PermissionsListRolesRequestBody defines model for V2PermissionsListRolesRequestBody.
type V2PermissionsListRolesRequestBody struct {
	// Cursor Cursor for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of roles to return
	Limit *int32 `json:"limit,omitempty"`
}

// V2PermissionsListRolesResponseBody defines model for V2PermissionsListRolesResponseBody.
type V2PermissionsListRolesResponseBody struct {
	Data PermissionsListRolesResponseData `json:"data"`
	Meta Meta                             `json:"meta"`
}

// V2RatelimitDeleteOverrideRequestBody Deletes an existing override.
type V2RatelimitDeleteOverrideRequestBody struct {
	// Identifier Identifier of the override to delete
	Identifier string `json:"identifier"`

	// NamespaceId The id of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitDeleteOverrideResponseBody defines model for V2RatelimitDeleteOverrideResponseBody.
type V2RatelimitDeleteOverrideResponseBody struct {
	Data RatelimitDeleteOverrideResponseData `json:"data"`
	Meta Meta                                `json:"meta"`
}

// V2RatelimitGetOverrideRequestBody Gets the configuration of an existing override.
type V2RatelimitGetOverrideRequestBody struct {
	// Identifier Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( * ) can be used to match multiple identifiers, More info can be found at https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules
	Identifier string `json:"identifier"`

	// NamespaceId The id of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitGetOverrideResponseBody defines model for V2RatelimitGetOverrideResponseBody.
type V2RatelimitGetOverrideResponseBody struct {
	Data RatelimitOverride `json:"data"`
	Meta Meta              `json:"meta"`
}

// V2RatelimitLimitRequestBody defines model for V2RatelimitLimitRequestBody.
type V2RatelimitLimitRequestBody struct {
	// Cost The cost of the request. Defaults to 1 if not provided.
	Cost *int64 `json:"cost,omitempty"`

	// Duration The duration in milliseconds for the rate limit window.
	Duration int64 `json:"duration"`

	// Identifier The identifier for the rate limit.
	Identifier string `json:"identifier"`

	// Limit The maximum number of requests allowed.
	Limit int64 `json:"limit"`

	// Namespace The namespace name for the rate limit.
	Namespace string `json:"namespace"`
}

// V2RatelimitLimitResponseBody defines model for V2RatelimitLimitResponseBody.
type V2RatelimitLimitResponseBody struct {
	Data RatelimitLimitResponseData `json:"data"`
	Meta Meta                       `json:"meta"`
}

// V2RatelimitListOverridesRequestBody defines model for V2RatelimitListOverridesRequestBody.
type V2RatelimitListOverridesRequestBody struct {
	// Cursor Pagination cursor from a previous response
	Cursor *string `json:"cursor,omitempty"`

	// Limit Maximum number of results to return
	Limit *int `json:"limit,omitempty"`

	// NamespaceId The id of the namespace to list overrides for.
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the namespace to list overrides for.
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitListOverridesResponseBody defines model for V2RatelimitListOverridesResponseBody.
type V2RatelimitListOverridesResponseBody struct {
	Data       RatelimitListOverridesResponseData `json:"data"`
	Meta       Meta                               `json:"meta"`
	Pagination *Pagination                        `json:"pagination,omitempty"`
}

// V2RatelimitSetOverrideRequestBody Sets a new or overwrites an existing override.
type V2RatelimitSetOverrideRequestBody struct {
	// Duration The duration in milliseconds for the rate limit window.
	Duration int64 `json:"duration"`

	// Identifier Identifier of your user, this can be their userId, an email, an ip or anything else. Wildcards ( * ) can be used to match multiple identifiers, More info can be found at https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules
	Identifier string `json:"identifier"`

	// Limit The maximum number of requests allowed.
	Limit int64 `json:"limit"`

	// NamespaceId The id of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the namespace. Either namespaceId or namespaceName must be provided
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitSetOverrideResponseBody defines model for V2RatelimitSetOverrideResponseBody.
type V2RatelimitSetOverrideResponseBody struct {
	Data RatelimitSetOverrideResponseData `json:"data"`
	Meta Meta                             `json:"meta"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Fix A human-readable message describing how to fix the error.
	Fix *string `json:"fix,omitempty"`

	// Location Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
	Location string `json:"location"`

	// Message Error message text
	Message string `json:"message"`
}

// CreateApiJSONRequestBody defines body for CreateApi for application/json ContentType.
type CreateApiJSONRequestBody = V2ApisCreateApiRequestBody

// DeleteApiJSONRequestBody defines body for DeleteApi for application/json ContentType.
type DeleteApiJSONRequestBody = V2ApisDeleteApiRequestBody

// GetApiJSONRequestBody defines body for GetApi for application/json ContentType.
type GetApiJSONRequestBody = V2ApisGetApiRequestBody

// ListKeysJSONRequestBody defines body for ListKeys for application/json ContentType.
type ListKeysJSONRequestBody = V2ApisListKeysRequestBody

// IdentitiesCreateIdentityJSONRequestBody defines body for IdentitiesCreateIdentity for application/json ContentType.
type IdentitiesCreateIdentityJSONRequestBody = V2IdentitiesCreateIdentityRequestBody

// V2IdentitiesDeleteIdentityJSONRequestBody defines body for V2IdentitiesDeleteIdentity for application/json ContentType.
type V2IdentitiesDeleteIdentityJSONRequestBody = V2IdentitiesDeleteIdentityRequestBody

// AddPermissionsJSONRequestBody defines body for AddPermissions for application/json ContentType.
type AddPermissionsJSONRequestBody = V2KeysAddPermissionsRequestBody

// CreateKeyJSONRequestBody defines body for CreateKey for application/json ContentType.
type CreateKeyJSONRequestBody = V2KeysCreateKeyRequestBody

// DeleteKeyJSONRequestBody defines body for DeleteKey for application/json ContentType.
type DeleteKeyJSONRequestBody = V2KeysDeleteKeyRequestBody

// GetKeyJSONRequestBody defines body for GetKey for application/json ContentType.
type GetKeyJSONRequestBody = V2KeysGetKeyRequestBody

// RemovePermissionsJSONRequestBody defines body for RemovePermissions for application/json ContentType.
type RemovePermissionsJSONRequestBody = V2KeysRemovePermissionsRequestBody

// UpdateKeyJSONRequestBody defines body for UpdateKey for application/json ContentType.
type UpdateKeyJSONRequestBody = V2KeysUpdateKeyRequestBody

// VerifyKeyJSONRequestBody defines body for VerifyKey for application/json ContentType.
type VerifyKeyJSONRequestBody = V2KeysVerifyKeyRequestBody

// CreatePermissionJSONRequestBody defines body for CreatePermission for application/json ContentType.
type CreatePermissionJSONRequestBody = V2PermissionsCreatePermissionRequestBody

// DeleteRoleJSONRequestBody defines body for DeleteRole for application/json ContentType.
type DeleteRoleJSONRequestBody = V2PermissionsDeleteRoleRequestBody

// GetPermissionJSONRequestBody defines body for GetPermission for application/json ContentType.
type GetPermissionJSONRequestBody = V2PermissionsGetPermissionRequestBody

// ListPermissionsJSONRequestBody defines body for ListPermissions for application/json ContentType.
type ListPermissionsJSONRequestBody = V2PermissionsListPermissionsRequestBody

// ListRolesJSONRequestBody defines body for ListRoles for application/json ContentType.
type ListRolesJSONRequestBody = V2PermissionsListRolesRequestBody

// RatelimitDeleteOverrideJSONRequestBody defines body for RatelimitDeleteOverride for application/json ContentType.
type RatelimitDeleteOverrideJSONRequestBody = V2RatelimitDeleteOverrideRequestBody

// RatelimitGetOverrideJSONRequestBody defines body for RatelimitGetOverride for application/json ContentType.
type RatelimitGetOverrideJSONRequestBody = V2RatelimitGetOverrideRequestBody

// RatelimitLimitJSONRequestBody defines body for RatelimitLimit for application/json ContentType.
type RatelimitLimitJSONRequestBody = V2RatelimitLimitRequestBody

// RatelimitListOverridesJSONRequestBody defines body for RatelimitListOverrides for application/json ContentType.
type RatelimitListOverridesJSONRequestBody = V2RatelimitListOverridesRequestBody

// RatelimitSetOverrideJSONRequestBody defines body for RatelimitSetOverride for application/json ContentType.
type RatelimitSetOverrideJSONRequestBody = V2RatelimitSetOverrideRequestBody

// AsV2IdentitiesDeleteIdentityRequestBody0 returns the union data inside the V2IdentitiesDeleteIdentityRequestBody as a V2IdentitiesDeleteIdentityRequestBody0
func (t V2IdentitiesDeleteIdentityRequestBody) AsV2IdentitiesDeleteIdentityRequestBody0() (V2IdentitiesDeleteIdentityRequestBody0, error) {
	var body V2IdentitiesDeleteIdentityRequestBody0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2IdentitiesDeleteIdentityRequestBody0 overwrites any union data inside the V2IdentitiesDeleteIdentityRequestBody as the provided V2IdentitiesDeleteIdentityRequestBody0
func (t *V2IdentitiesDeleteIdentityRequestBody) FromV2IdentitiesDeleteIdentityRequestBody0(v V2IdentitiesDeleteIdentityRequestBody0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2IdentitiesDeleteIdentityRequestBody0 performs a merge with any union data inside the V2IdentitiesDeleteIdentityRequestBody, using the provided V2IdentitiesDeleteIdentityRequestBody0
func (t *V2IdentitiesDeleteIdentityRequestBody) MergeV2IdentitiesDeleteIdentityRequestBody0(v V2IdentitiesDeleteIdentityRequestBody0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV2IdentitiesDeleteIdentityRequestBody1 returns the union data inside the V2IdentitiesDeleteIdentityRequestBody as a V2IdentitiesDeleteIdentityRequestBody1
func (t V2IdentitiesDeleteIdentityRequestBody) AsV2IdentitiesDeleteIdentityRequestBody1() (V2IdentitiesDeleteIdentityRequestBody1, error) {
	var body V2IdentitiesDeleteIdentityRequestBody1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2IdentitiesDeleteIdentityRequestBody1 overwrites any union data inside the V2IdentitiesDeleteIdentityRequestBody as the provided V2IdentitiesDeleteIdentityRequestBody1
func (t *V2IdentitiesDeleteIdentityRequestBody) FromV2IdentitiesDeleteIdentityRequestBody1(v V2IdentitiesDeleteIdentityRequestBody1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2IdentitiesDeleteIdentityRequestBody1 performs a merge with any union data inside the V2IdentitiesDeleteIdentityRequestBody, using the provided V2IdentitiesDeleteIdentityRequestBody1
func (t *V2IdentitiesDeleteIdentityRequestBody) MergeV2IdentitiesDeleteIdentityRequestBody1(v V2IdentitiesDeleteIdentityRequestBody1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V2IdentitiesDeleteIdentityRequestBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.ExternalId != nil {
		object["externalId"], err = json.Marshal(t.ExternalId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'externalId': %w", err)
		}
	}

	if t.IdentityId != nil {
		object["identityId"], err = json.Marshal(t.IdentityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'identityId': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *V2IdentitiesDeleteIdentityRequestBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["externalId"]; found {
		err = json.Unmarshal(raw, &t.ExternalId)
		if err != nil {
			return fmt.Errorf("error reading 'externalId': %w", err)
		}
	}

	if raw, found := object["identityId"]; found {
		err = json.Unmarshal(raw, &t.IdentityId)
		if err != nil {
			return fmt.Errorf("error reading 'identityId': %w", err)
		}
	}

	return err
}

// AsV2KeysVerifyKeyRequestBodyPermissions0 returns the union data inside the V2KeysVerifyKeyRequestBody_Permissions as a V2KeysVerifyKeyRequestBodyPermissions0
func (t V2KeysVerifyKeyRequestBody_Permissions) AsV2KeysVerifyKeyRequestBodyPermissions0() (V2KeysVerifyKeyRequestBodyPermissions0, error) {
	var body V2KeysVerifyKeyRequestBodyPermissions0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2KeysVerifyKeyRequestBodyPermissions0 overwrites any union data inside the V2KeysVerifyKeyRequestBody_Permissions as the provided V2KeysVerifyKeyRequestBodyPermissions0
func (t *V2KeysVerifyKeyRequestBody_Permissions) FromV2KeysVerifyKeyRequestBodyPermissions0(v V2KeysVerifyKeyRequestBodyPermissions0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2KeysVerifyKeyRequestBodyPermissions0 performs a merge with any union data inside the V2KeysVerifyKeyRequestBody_Permissions, using the provided V2KeysVerifyKeyRequestBodyPermissions0
func (t *V2KeysVerifyKeyRequestBody_Permissions) MergeV2KeysVerifyKeyRequestBodyPermissions0(v V2KeysVerifyKeyRequestBodyPermissions0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV2KeysVerifyKeyRequestBodyPermissions1 returns the union data inside the V2KeysVerifyKeyRequestBody_Permissions as a V2KeysVerifyKeyRequestBodyPermissions1
func (t V2KeysVerifyKeyRequestBody_Permissions) AsV2KeysVerifyKeyRequestBodyPermissions1() (V2KeysVerifyKeyRequestBodyPermissions1, error) {
	var body V2KeysVerifyKeyRequestBodyPermissions1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2KeysVerifyKeyRequestBodyPermissions1 overwrites any union data inside the V2KeysVerifyKeyRequestBody_Permissions as the provided V2KeysVerifyKeyRequestBodyPermissions1
func (t *V2KeysVerifyKeyRequestBody_Permissions) FromV2KeysVerifyKeyRequestBodyPermissions1(v V2KeysVerifyKeyRequestBodyPermissions1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2KeysVerifyKeyRequestBodyPermissions1 performs a merge with any union data inside the V2KeysVerifyKeyRequestBody_Permissions, using the provided V2KeysVerifyKeyRequestBodyPermissions1
func (t *V2KeysVerifyKeyRequestBody_Permissions) MergeV2KeysVerifyKeyRequestBodyPermissions1(v V2KeysVerifyKeyRequestBodyPermissions1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V2KeysVerifyKeyRequestBody_Permissions) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V2KeysVerifyKeyRequestBody_Permissions) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
